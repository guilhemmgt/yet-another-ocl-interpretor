grammar fr.enseeiht.ocl.xtext.Ocl with org.eclipse.xtext.common.Terminals

generate ocl "http://www.enseeiht.fr/ocl/xtext/Ocl"

import "http://www.eclipse.org/emf/2002/Ecore" as ecore

Module:
	(imports+=Import)+ (contextlessFeatures+=OclFeatureDefinition)* (contextBlocks+=OclContextBlock)+
;


Import:
'import' package=[ecore::EPackage|STRING] 'as'name=ID;

OclContextBlock:
	('context' ecoreTypes=[Import]'!'class=[ecore::EClass|QualifiedName]) (members+=(OclFeatureDefinition|OclInvariant))+
;
OclFeatureDefinition:
	'def' ':' feature = (Attribute|Operation)
;
Attribute :
	name=ID ':' type=OclTypeLiteral '=' initExpression=OclExpression
;
Operation:
	name=ID  '(' (parameters+=Parameter (',' parameters+=Parameter)+)? ')' ':' returnType=OclTypeLiteral '=' body=OclExpression
;
Parameter:
	name=ID ':' type=OclTypeLiteral
;
OclInvariant:
	'inv' name=ID ':' body=OclExpression
;
OclExpression returns OclExpression :
	OperatorCallExp|LetExp;

OclModelElementExp :
	model=[Import]'!'name=ID
;

//priority_5

OperatorCallExp returns OclExpression :
	EqOpCallExp (({OperatorCallExp.source=current} operationName=BOOLOP) 	argument=EqOpCallExp )*
;

BOOLOP  		: 'and'|'or'|'xor'|'implies'|'equivalent';

EqOpCallExp returns OperatorCallExp :
	RelOpCallExp (({EqOpCallExp.source=current} operationName=EQOP) 	argument=RelOpCallExp )?
;
EQOP  		: '='|'<>';

RelOpCallExp returns OperatorCallExp :
	AddOpCallExp (({RelOpCallExp.source=current} operationName=RELOP) 	argument=AddOpCallExp )?
;

RELOP  		: '>'|'<'|'>='|'<=' ;

AddOpCallExp returns OperatorCallExp :
	IntOpCallExp (({AddOpCallExp.source=current} operationName=ADDOP) 	argument=IntOpCallExp )*
;
 ADDOP : '-'|'+';

IntOpCallExp returns OperatorCallExp :
	MulOpCallExp (({IntOpCallExp.source=current} operationName=INTOP) 	argument=MulOpCallExp )*
;
INTOP : 'div'|'mod';

MulOpCallExp returns OperatorCallExp :
	NotOpCallExp (({MulOpCallExp.source=current} operationName=MULOP) 	argument=NotOpCallExp )*
;
MULOP: '*'|'/';

NotOpCallExp returns OperatorCallExp :
	((operationName=UNARYOP source=NotOpCallExp) 
		| 
		PropertyCallExp)
;
UNARYOP: 'not' | '-'
;
//priority_0
PropertyCallExp  :
	source = Primary_OclExpression (calls+=PropertyCall)*
	;

Primary_OclExpression returns OclExpression : 
	VariableExp
	|SelfLiteralExp
	|StringLiteralExp
	|BooleanLiteralExp
	|NumericLiteralExp
	|BagLiteralExp
	|OrderedSetLiteralExp
	|SequenceLiteralExp
	|SetLiteralExp
	|TupleLiteralExp
	|MapLiteralExp
	|EnumLiteralExp
	|IfExp
	|BraceExp
	|OclModelElementExp;

Auxiliary :Iterator|LocalVariable|Parameter;
VariableExp:
	referredVariable=[Auxiliary]
;
SelfLiteralExp :
	{SelfLiteralExp}	'self'
;
StringLiteralExp :
	{StringLiteralExp}
	stringSymbol=STRING
;
NumericLiteralExp: 
	RealLiteralExp|IntegerLiteralExp
;
RealLiteralExp : realSymbol=DOUBLE;


IntegerLiteralExp:
	{IntegerLiteralExp}
	integerSymbol=INT
;
BagLiteralExp:
	{BagLiteralExp}
	'Bag' '{' (elements+=OclExpression ("," elements+=OclExpression)*)? '}'
;
OrderedSetLiteralExp:
	{OrderedSetLiteralExp}
	'OrderedSet' '{' (elements+=OclExpression ("," elements+=OclExpression)*)? '}'
;
SequenceLiteralExp:
	{SequenceLiteralExp}
	'Sequence' '{' (elements+=OclExpression ("," elements+=OclExpression)*)? '}'
;
SetLiteralExp:
	{SetLiteralExp}
	'Set' '{' (elements+=OclExpression ("," elements+=OclExpression)*)? '}'
;
TupleLiteralExp:
	{TupleLiteralExp}
	'Tuple' '{' (tuplePart+=TuplePart ("," tuplePart+=TuplePart)*)? '}'
;
TuplePart:
	varName=STRING (':' type=OclTypeLiteral)? '=' initExpression=OclExpression
;
MapLiteralExp : 
	{MapLiteralExp}
	'Map' '{' (elements+=MapElement (',' elements+=MapElement)*)? '}'
;

MapElement : 
	'(' key=OclExpression ',' value=OclExpression ')'
;

EnumLiteralExp : 
	"#" (name=STRING|name=ID)
;

LetExp : 
	'let' variable=LocalVariable 'in' in_=OclExpression
;

IfExp : 
	'if' condition=OclExpression 'then' thenExpression=OclExpression 'else' elseExpression=OclExpression 'endif'
;

BraceExp : 
	'(' exp=OclExpression ')'
;
	
BooleanLiteralExp:
	booleanSymbol= 'true'|booleanSymbol= 'false'
	;
	
PropertyCall:
	OperationCall|NavigationOrAttributeCall|IterateExp|IteratorExp|CollectionOperationCall
	;
	
OperationCall:
	'.' (operationName=STRING|operationName=ID) '(' (arguments+=OclExpression (',' arguments+=OclExpression)*)? ')'
	;

NavigationOrAttributeCall : 
	'.' (name=STRING|name=ID)
	;

IterateExp:
	'->' 'iterate' '(' iterators+=Iterator (',' iterators+=Iterator)* ';' result=LocalVariable '|' body=OclExpression ')'
	;
	
Iterator : 
	name=ID (':' type=OclTypeLiteral)?
	;

IteratorExp : 
	'->' name=ID '(' iterators+=Iterator (',' iterators+=Iterator)* '|' body=OclExpression ')'
	;

CollectionOperationCall : 
	'->' operationName=ID '(' (arguments+=OclExpression (',' arguments+=OclExpression)*)? ')'
	;

LocalVariable : 
	name=ID (':' type=OclTypeLiteral)? '=' initExpression=OclExpression
;
OclTypeLiteral : 
	CollectionType
	| Primitive 
	| OclAnyType 
	| TupleType 
	| OclModelElementClass
	| MapType 
	;

CollectionType:
	BagType
	| OrderedSetType 
	| SequenceType 
	| SetType 
	;

BagType :
	'Bag' '(' elementType=OclTypeLiteral ')'
;

OrderedSetType :
	'OrderedSet' '(' elementType=OclTypeLiteral ')'
;

SequenceType :
	'Sequence' '(' elementType=OclTypeLiteral ')'
;

SetType :
	'Set' '(' elementType=OclTypeLiteral ')'
;

Primitive:
	StringType
	| BooleanType 
	| NumericType 
;

StringType:
	{StringType}'String'
;

BooleanType:
	{BooleanType}'Boolean'
;

NumericType:
	IntegerType
	|RealType
;

IntegerType:
	{IntegerType}'Integer'
;

RealType:
	{RealType}'Real'
;

OclAnyType :
	{OclAnyType}'OclAny'
;
	
TupleType :
	{TupleType}
	 ('Tuple') '(' (attributes+=TupleTypeAttribute (',' attributes+=TupleTypeAttribute)*)? ')'
	 ;
	 
TupleTypeAttribute : name=ID ':' type=OclTypeLiteral;

OclModelElementClass: model=[Import]'!'name=ID;
	
MapType : 
	'Map' '(' keyType=OclTypeLiteral ',' valueType=OclTypeLiteral ')'
;


terminal DOUBLE returns ecore::EDouble :
(INT '.' INT| '.' INT | INT '.') ('e' ('-'|'+') INT)?;

QualifiedName: ID ('.' ID)*;


@Override
terminal SL_COMMENT:
    '--' .* '\n'
;
	