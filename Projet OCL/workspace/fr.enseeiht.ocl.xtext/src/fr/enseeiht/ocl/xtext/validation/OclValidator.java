/*
 * generated by Xtext 2.37.0
 */
package fr.enseeiht.ocl.xtext.validation;

import fr.enseeiht.ocl.xtext.types.OclInvalid;

import java.util.List;

import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.validation.Check;

import fr.enseeiht.ocl.xtext.ocl.Module;

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
public class OclValidator extends AbstractOclValidator {
	
	public static final String CHECK_TYPE_DIAGNOSTIC = "org.eclipse.xtext.diagnostics.Diagnostic.CheckType";	
	private static final String CHECK_TYPE_DIAGNOSTIC_TEMP_EXCEPTION = "org.eclipse.xtext.diagnostics.Diagnostic.CheckType.Exception";
	
	/**
	 * Type Checking for the OCL syntax. Should not be called manually.
	 * @param module the root element
	 */
	@Check
	public void checkType(Module module) {
		// On check le type uniquement si il n'y pas d'erreur de syntaxe
		if (module.eResource().getErrors().isEmpty()) {
			try {
				// Récupérer les erreurs de typages
				OclInvalid invalid = OclTypeChecker.getAllTypes(module);

				for (TypeCheckingError error : invalid.origins) {
					EObject target = error.getCause();
					EObject container = target.eContainer();
					// Si l'erreur de typage est dans un attrbut qui est une liste il faut savoir lequel de ses élements a levé une erreur
					if (container.eGet(target.eContainingFeature()) instanceof List) {
						@SuppressWarnings("unchecked")
						List<EObject> features = (List<EObject>) container.eGet(target.eContainingFeature());
						error(error.getMessage(), container, target.eContainingFeature(), features.indexOf(target),
								CHECK_TYPE_DIAGNOSTIC, new String[0]);
					} else {
						error(error.getMessage(), container, target.eContainingFeature(), CHECK_TYPE_DIAGNOSTIC,
								new String[0]);
					}
				}
			} catch (Exception e) {
				// Si le typeur a eu une erreur
				e.printStackTrace();
				// Afficher un warning si notre code a planté pour mettre au courant l'utilisateur final
				// Normalement le comportement normal est de laisser remonter l'erreur, XText va ainsi afficher qu'il y a un problème 
				// Mais, si on fait ca, alors l'achitecture de tests ne fonctionnent plus parce que toutes les exceptions sont catch par Xtext
				// Donc c'est le moins pire qu'on puisse faire pour accorder les 2 bouts
				warning(e.getMessage(), module.eClass().getEStructuralFeature("contextBlocks"),
						CHECK_TYPE_DIAGNOSTIC_TEMP_EXCEPTION, new String[] { e.getClass().toString().split(" ")[1] });

			}
		}
	}
//	public static final String INVALID_NAME = "invalidName";
//
//	@Check
//	public void checkGreetingStartsWithCapital(Greeting greeting) {
//		if (!Character.isUpperCase(greeting.getName().charAt(0))) {
//			warning("Name should start with a capital",
//					OclPackage.Literals.GREETING__NAME,
//					INVALID_NAME);
//		}
//	}
	
}
