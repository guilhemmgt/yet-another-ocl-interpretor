/*
 * generated by Xtext
 */
package fr.enseeiht.ocl.xtext.serializer;

import com.google.inject.Inject;
import fr.enseeiht.ocl.xtext.ocl.AddOpCallExp;
import fr.enseeiht.ocl.xtext.ocl.Attribute;
import fr.enseeiht.ocl.xtext.ocl.BagLiteralExp;
import fr.enseeiht.ocl.xtext.ocl.BagType;
import fr.enseeiht.ocl.xtext.ocl.BooleanLiteralExp;
import fr.enseeiht.ocl.xtext.ocl.BooleanType;
import fr.enseeiht.ocl.xtext.ocl.BraceExp;
import fr.enseeiht.ocl.xtext.ocl.CollectionOperationCall;
import fr.enseeiht.ocl.xtext.ocl.CollectionType;
import fr.enseeiht.ocl.xtext.ocl.ContextlessCallExp;
import fr.enseeiht.ocl.xtext.ocl.EnumLiteralExp;
import fr.enseeiht.ocl.xtext.ocl.EqOpCallExp;
import fr.enseeiht.ocl.xtext.ocl.IfExp;
import fr.enseeiht.ocl.xtext.ocl.Import;
import fr.enseeiht.ocl.xtext.ocl.IntOpCallExp;
import fr.enseeiht.ocl.xtext.ocl.IntegerLiteralExp;
import fr.enseeiht.ocl.xtext.ocl.IntegerType;
import fr.enseeiht.ocl.xtext.ocl.IterateExp;
import fr.enseeiht.ocl.xtext.ocl.Iterator;
import fr.enseeiht.ocl.xtext.ocl.IteratorExp;
import fr.enseeiht.ocl.xtext.ocl.LetExp;
import fr.enseeiht.ocl.xtext.ocl.LocalVariable;
import fr.enseeiht.ocl.xtext.ocl.MapElement;
import fr.enseeiht.ocl.xtext.ocl.MapLiteralExp;
import fr.enseeiht.ocl.xtext.ocl.MapType;
import fr.enseeiht.ocl.xtext.ocl.MulOpCallExp;
import fr.enseeiht.ocl.xtext.ocl.NavigationOrAttributeCall;
import fr.enseeiht.ocl.xtext.ocl.NotOpCallExp;
import fr.enseeiht.ocl.xtext.ocl.NullLiteralExp;
import fr.enseeiht.ocl.xtext.ocl.OclAnyType;
import fr.enseeiht.ocl.xtext.ocl.OclContextBlock;
import fr.enseeiht.ocl.xtext.ocl.OclFeatureDefinition;
import fr.enseeiht.ocl.xtext.ocl.OclInvariant;
import fr.enseeiht.ocl.xtext.ocl.OclModelElementClass;
import fr.enseeiht.ocl.xtext.ocl.OclModelElementExp;
import fr.enseeiht.ocl.xtext.ocl.OclPackage;
import fr.enseeiht.ocl.xtext.ocl.OclVoidType;
import fr.enseeiht.ocl.xtext.ocl.Operation;
import fr.enseeiht.ocl.xtext.ocl.OperationCall;
import fr.enseeiht.ocl.xtext.ocl.OperatorCallExp;
import fr.enseeiht.ocl.xtext.ocl.OrderedSetLiteralExp;
import fr.enseeiht.ocl.xtext.ocl.OrderedSetType;
import fr.enseeiht.ocl.xtext.ocl.PropertyCallExp;
import fr.enseeiht.ocl.xtext.ocl.RealLiteralExp;
import fr.enseeiht.ocl.xtext.ocl.RealType;
import fr.enseeiht.ocl.xtext.ocl.RelOpCallExp;
import fr.enseeiht.ocl.xtext.ocl.SelfLiteralExp;
import fr.enseeiht.ocl.xtext.ocl.SequenceLiteralExp;
import fr.enseeiht.ocl.xtext.ocl.SequenceType;
import fr.enseeiht.ocl.xtext.ocl.SetLiteralExp;
import fr.enseeiht.ocl.xtext.ocl.SetType;
import fr.enseeiht.ocl.xtext.ocl.StringLiteralExp;
import fr.enseeiht.ocl.xtext.ocl.StringType;
import fr.enseeiht.ocl.xtext.ocl.TupleLiteralExp;
import fr.enseeiht.ocl.xtext.ocl.TuplePart;
import fr.enseeiht.ocl.xtext.ocl.TupleType;
import fr.enseeiht.ocl.xtext.ocl.TupleTypeAttribute;
import fr.enseeiht.ocl.xtext.ocl.VariableExp;
import fr.enseeiht.ocl.xtext.services.OclGrammarAccess;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class OclSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private OclGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == OclPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case OclPackage.ADD_OP_CALL_EXP:
				sequence_AddOpCallExp(context, (AddOpCallExp) semanticObject); 
				return; 
			case OclPackage.ATTRIBUTE:
				sequence_Attribute(context, (Attribute) semanticObject); 
				return; 
			case OclPackage.BAG_LITERAL_EXP:
				sequence_BagLiteralExp(context, (BagLiteralExp) semanticObject); 
				return; 
			case OclPackage.BAG_TYPE:
				sequence_BagType(context, (BagType) semanticObject); 
				return; 
			case OclPackage.BOOLEAN_LITERAL_EXP:
				sequence_BooleanLiteralExp(context, (BooleanLiteralExp) semanticObject); 
				return; 
			case OclPackage.BOOLEAN_TYPE:
				sequence_BooleanType(context, (BooleanType) semanticObject); 
				return; 
			case OclPackage.BRACE_EXP:
				sequence_BraceExp(context, (BraceExp) semanticObject); 
				return; 
			case OclPackage.COLLECTION_OPERATION_CALL:
				sequence_CollectionOperationCall(context, (CollectionOperationCall) semanticObject); 
				return; 
			case OclPackage.COLLECTION_TYPE:
				sequence_CollectionType(context, (CollectionType) semanticObject); 
				return; 
			case OclPackage.CONTEXTLESS_CALL_EXP:
				sequence_ContextlessCallExp(context, (ContextlessCallExp) semanticObject); 
				return; 
			case OclPackage.ENUM_LITERAL_EXP:
				sequence_EnumLiteralExp(context, (EnumLiteralExp) semanticObject); 
				return; 
			case OclPackage.EQ_OP_CALL_EXP:
				sequence_EqOpCallExp(context, (EqOpCallExp) semanticObject); 
				return; 
			case OclPackage.IF_EXP:
				sequence_IfExp(context, (IfExp) semanticObject); 
				return; 
			case OclPackage.IMPORT:
				sequence_Import(context, (Import) semanticObject); 
				return; 
			case OclPackage.INT_OP_CALL_EXP:
				sequence_IntOpCallExp(context, (IntOpCallExp) semanticObject); 
				return; 
			case OclPackage.INTEGER_LITERAL_EXP:
				sequence_IntegerLiteralExp(context, (IntegerLiteralExp) semanticObject); 
				return; 
			case OclPackage.INTEGER_TYPE:
				sequence_IntegerType(context, (IntegerType) semanticObject); 
				return; 
			case OclPackage.ITERATE_EXP:
				sequence_IterateExp(context, (IterateExp) semanticObject); 
				return; 
			case OclPackage.ITERATOR:
				sequence_Iterator(context, (Iterator) semanticObject); 
				return; 
			case OclPackage.ITERATOR_EXP:
				sequence_IteratorExp(context, (IteratorExp) semanticObject); 
				return; 
			case OclPackage.LET_EXP:
				sequence_LetExp(context, (LetExp) semanticObject); 
				return; 
			case OclPackage.LOCAL_VARIABLE:
				sequence_LocalVariable(context, (LocalVariable) semanticObject); 
				return; 
			case OclPackage.MAP_ELEMENT:
				sequence_MapElement(context, (MapElement) semanticObject); 
				return; 
			case OclPackage.MAP_LITERAL_EXP:
				sequence_MapLiteralExp(context, (MapLiteralExp) semanticObject); 
				return; 
			case OclPackage.MAP_TYPE:
				sequence_MapType(context, (MapType) semanticObject); 
				return; 
			case OclPackage.MODULE:
				sequence_Module(context, (fr.enseeiht.ocl.xtext.ocl.Module) semanticObject); 
				return; 
			case OclPackage.MUL_OP_CALL_EXP:
				sequence_MulOpCallExp(context, (MulOpCallExp) semanticObject); 
				return; 
			case OclPackage.NAVIGATION_OR_ATTRIBUTE_CALL:
				sequence_NavigationOrAttributeCall(context, (NavigationOrAttributeCall) semanticObject); 
				return; 
			case OclPackage.NOT_OP_CALL_EXP:
				sequence_NotOpCallExp(context, (NotOpCallExp) semanticObject); 
				return; 
			case OclPackage.NULL_LITERAL_EXP:
				sequence_NullLiteralExp(context, (NullLiteralExp) semanticObject); 
				return; 
			case OclPackage.OCL_ANY_TYPE:
				sequence_OclAnyType(context, (OclAnyType) semanticObject); 
				return; 
			case OclPackage.OCL_CONTEXT_BLOCK:
				sequence_OclContextBlock(context, (OclContextBlock) semanticObject); 
				return; 
			case OclPackage.OCL_FEATURE_DEFINITION:
				sequence_OclFeatureDefinition(context, (OclFeatureDefinition) semanticObject); 
				return; 
			case OclPackage.OCL_INVARIANT:
				sequence_OclInvariant(context, (OclInvariant) semanticObject); 
				return; 
			case OclPackage.OCL_MODEL_ELEMENT_CLASS:
				sequence_OclModelElementClass(context, (OclModelElementClass) semanticObject); 
				return; 
			case OclPackage.OCL_MODEL_ELEMENT_EXP:
				sequence_OclModelElementExp(context, (OclModelElementExp) semanticObject); 
				return; 
			case OclPackage.OCL_VOID_TYPE:
				sequence_OclVoidType(context, (OclVoidType) semanticObject); 
				return; 
			case OclPackage.OPERATION:
				sequence_Operation(context, (Operation) semanticObject); 
				return; 
			case OclPackage.OPERATION_CALL:
				sequence_OperationCall(context, (OperationCall) semanticObject); 
				return; 
			case OclPackage.OPERATOR_CALL_EXP:
				sequence_OperatorCallExp(context, (OperatorCallExp) semanticObject); 
				return; 
			case OclPackage.ORDERED_SET_LITERAL_EXP:
				sequence_OrderedSetLiteralExp(context, (OrderedSetLiteralExp) semanticObject); 
				return; 
			case OclPackage.ORDERED_SET_TYPE:
				sequence_OrderedSetType(context, (OrderedSetType) semanticObject); 
				return; 
			case OclPackage.PARAMETER:
				sequence_Parameter(context, (fr.enseeiht.ocl.xtext.ocl.Parameter) semanticObject); 
				return; 
			case OclPackage.PROPERTY_CALL_EXP:
				sequence_PropertyCallExp(context, (PropertyCallExp) semanticObject); 
				return; 
			case OclPackage.REAL_LITERAL_EXP:
				sequence_RealLiteralExp(context, (RealLiteralExp) semanticObject); 
				return; 
			case OclPackage.REAL_TYPE:
				sequence_RealType(context, (RealType) semanticObject); 
				return; 
			case OclPackage.REL_OP_CALL_EXP:
				sequence_RelOpCallExp(context, (RelOpCallExp) semanticObject); 
				return; 
			case OclPackage.SELF_LITERAL_EXP:
				sequence_SelfLiteralExp(context, (SelfLiteralExp) semanticObject); 
				return; 
			case OclPackage.SEQUENCE_LITERAL_EXP:
				sequence_SequenceLiteralExp(context, (SequenceLiteralExp) semanticObject); 
				return; 
			case OclPackage.SEQUENCE_TYPE:
				sequence_SequenceType(context, (SequenceType) semanticObject); 
				return; 
			case OclPackage.SET_LITERAL_EXP:
				sequence_SetLiteralExp(context, (SetLiteralExp) semanticObject); 
				return; 
			case OclPackage.SET_TYPE:
				sequence_SetType(context, (SetType) semanticObject); 
				return; 
			case OclPackage.STRING_LITERAL_EXP:
				sequence_StringLiteralExp(context, (StringLiteralExp) semanticObject); 
				return; 
			case OclPackage.STRING_TYPE:
				sequence_StringType(context, (StringType) semanticObject); 
				return; 
			case OclPackage.TUPLE_LITERAL_EXP:
				sequence_TupleLiteralExp(context, (TupleLiteralExp) semanticObject); 
				return; 
			case OclPackage.TUPLE_PART:
				sequence_TuplePart(context, (TuplePart) semanticObject); 
				return; 
			case OclPackage.TUPLE_TYPE:
				sequence_TupleType(context, (TupleType) semanticObject); 
				return; 
			case OclPackage.TUPLE_TYPE_ATTRIBUTE:
				sequence_TupleTypeAttribute(context, (TupleTypeAttribute) semanticObject); 
				return; 
			case OclPackage.VARIABLE_EXP:
				sequence_VariableExp(context, (VariableExp) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * <pre>
	 * Contexts:
	 *     AddOpCallExp returns AddOpCallExp
	 *
	 * Constraint:
	 *     (args+=IntOpCallExp (operationNames+=ADDOP args+=IntOpCallExp)*)
	 * </pre>
	 */
	protected void sequence_AddOpCallExp(ISerializationContext context, AddOpCallExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Attribute returns Attribute
	 *     Auxiliary returns Attribute
	 *
	 * Constraint:
	 *     (name=ID type=OclTypeLiteral initExpression=OclExpression)
	 * </pre>
	 */
	protected void sequence_Attribute(ISerializationContext context, Attribute semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OclPackage.Literals.AUXILIARY__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OclPackage.Literals.AUXILIARY__NAME));
			if (transientValues.isValueTransient(semanticObject, OclPackage.Literals.AUXILIARY__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OclPackage.Literals.AUXILIARY__TYPE));
			if (transientValues.isValueTransient(semanticObject, OclPackage.Literals.ATTRIBUTE__INIT_EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OclPackage.Literals.ATTRIBUTE__INIT_EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAttributeAccess().getNameIDTerminalRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getAttributeAccess().getTypeOclTypeLiteralParserRuleCall_2_0(), semanticObject.getType());
		feeder.accept(grammarAccess.getAttributeAccess().getInitExpressionOclExpressionParserRuleCall_4_0(), semanticObject.getInitExpression());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Primary_OclExpression returns BagLiteralExp
	 *     BagLiteralExp returns BagLiteralExp
	 *
	 * Constraint:
	 *     (elements+=OclExpression elements+=OclExpression*)?
	 * </pre>
	 */
	protected void sequence_BagLiteralExp(ISerializationContext context, BagLiteralExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     OclTypeLiteral returns BagType
	 *     CollectionTypeLiteral returns BagType
	 *     BagType returns BagType
	 *
	 * Constraint:
	 *     elementType=OclTypeLiteral
	 * </pre>
	 */
	protected void sequence_BagType(ISerializationContext context, BagType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OclPackage.Literals.COLLECTION_TYPE_LITERAL__ELEMENT_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OclPackage.Literals.COLLECTION_TYPE_LITERAL__ELEMENT_TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBagTypeAccess().getElementTypeOclTypeLiteralParserRuleCall_2_0(), semanticObject.getElementType());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Primary_OclExpression returns BooleanLiteralExp
	 *     BooleanLiteralExp returns BooleanLiteralExp
	 *
	 * Constraint:
	 *     (booleanSymbol='true' | booleanSymbol='false')
	 * </pre>
	 */
	protected void sequence_BooleanLiteralExp(ISerializationContext context, BooleanLiteralExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     OclTypeLiteral returns BooleanType
	 *     Primitive returns BooleanType
	 *     BooleanType returns BooleanType
	 *
	 * Constraint:
	 *     {BooleanType}
	 * </pre>
	 */
	protected void sequence_BooleanType(ISerializationContext context, BooleanType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Primary_OclExpression returns BraceExp
	 *     BraceExp returns BraceExp
	 *
	 * Constraint:
	 *     exp=OclExpression
	 * </pre>
	 */
	protected void sequence_BraceExp(ISerializationContext context, BraceExp semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OclPackage.Literals.BRACE_EXP__EXP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OclPackage.Literals.BRACE_EXP__EXP));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBraceExpAccess().getExpOclExpressionParserRuleCall_1_0(), semanticObject.getExp());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     PropertyCall returns CollectionOperationCall
	 *     CollectionOperationCall returns CollectionOperationCall
	 *
	 * Constraint:
	 *     (operationName=ID (arguments+=OclExpression arguments+=OclExpression*)?)
	 * </pre>
	 */
	protected void sequence_CollectionOperationCall(ISerializationContext context, CollectionOperationCall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     OclTypeLiteral returns CollectionType
	 *     CollectionTypeLiteral returns CollectionType
	 *     CollectionType returns CollectionType
	 *
	 * Constraint:
	 *     elementType=OclTypeLiteral
	 * </pre>
	 */
	protected void sequence_CollectionType(ISerializationContext context, CollectionType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OclPackage.Literals.COLLECTION_TYPE_LITERAL__ELEMENT_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OclPackage.Literals.COLLECTION_TYPE_LITERAL__ELEMENT_TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCollectionTypeAccess().getElementTypeOclTypeLiteralParserRuleCall_2_0(), semanticObject.getElementType());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Primary_OclExpression returns ContextlessCallExp
	 *     ContextlessCallExp returns ContextlessCallExp
	 *
	 * Constraint:
	 *     (operationName=ID (arguments+=OclExpression arguments+=OclExpression*)?)
	 * </pre>
	 */
	protected void sequence_ContextlessCallExp(ISerializationContext context, ContextlessCallExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Primary_OclExpression returns EnumLiteralExp
	 *     EnumLiteralExp returns EnumLiteralExp
	 *
	 * Constraint:
	 *     (ecoreTypes=[Import|ID] enum_=[EEnum|QualifiedName] name=ID)
	 * </pre>
	 */
	protected void sequence_EnumLiteralExp(ISerializationContext context, EnumLiteralExp semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OclPackage.Literals.ENUM_LITERAL_EXP__ECORE_TYPES) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OclPackage.Literals.ENUM_LITERAL_EXP__ECORE_TYPES));
			if (transientValues.isValueTransient(semanticObject, OclPackage.Literals.ENUM_LITERAL_EXP__ENUM_) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OclPackage.Literals.ENUM_LITERAL_EXP__ENUM_));
			if (transientValues.isValueTransient(semanticObject, OclPackage.Literals.ENUM_LITERAL_EXP__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OclPackage.Literals.ENUM_LITERAL_EXP__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEnumLiteralExpAccess().getEcoreTypesImportIDTerminalRuleCall_0_0_1(), semanticObject.eGet(OclPackage.Literals.ENUM_LITERAL_EXP__ECORE_TYPES, false));
		feeder.accept(grammarAccess.getEnumLiteralExpAccess().getEnum_EEnumQualifiedNameParserRuleCall_2_0_1(), semanticObject.eGet(OclPackage.Literals.ENUM_LITERAL_EXP__ENUM_, false));
		feeder.accept(grammarAccess.getEnumLiteralExpAccess().getNameIDTerminalRuleCall_4_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EqOpCallExp returns EqOpCallExp
	 *
	 * Constraint:
	 *     (args+=RelOpCallExp (operationNames+=EQOP args+=RelOpCallExp)?)
	 * </pre>
	 */
	protected void sequence_EqOpCallExp(ISerializationContext context, EqOpCallExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Primary_OclExpression returns IfExp
	 *     IfExp returns IfExp
	 *
	 * Constraint:
	 *     (condition=OclExpression thenExpression=OclExpression elseExpression=OclExpression)
	 * </pre>
	 */
	protected void sequence_IfExp(ISerializationContext context, IfExp semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OclPackage.Literals.IF_EXP__CONDITION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OclPackage.Literals.IF_EXP__CONDITION));
			if (transientValues.isValueTransient(semanticObject, OclPackage.Literals.IF_EXP__THEN_EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OclPackage.Literals.IF_EXP__THEN_EXPRESSION));
			if (transientValues.isValueTransient(semanticObject, OclPackage.Literals.IF_EXP__ELSE_EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OclPackage.Literals.IF_EXP__ELSE_EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIfExpAccess().getConditionOclExpressionParserRuleCall_1_0(), semanticObject.getCondition());
		feeder.accept(grammarAccess.getIfExpAccess().getThenExpressionOclExpressionParserRuleCall_3_0(), semanticObject.getThenExpression());
		feeder.accept(grammarAccess.getIfExpAccess().getElseExpressionOclExpressionParserRuleCall_5_0(), semanticObject.getElseExpression());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Import returns Import
	 *
	 * Constraint:
	 *     (package=[EPackage|STRING] name=ID)
	 * </pre>
	 */
	protected void sequence_Import(ISerializationContext context, Import semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OclPackage.Literals.IMPORT__PACKAGE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OclPackage.Literals.IMPORT__PACKAGE));
			if (transientValues.isValueTransient(semanticObject, OclPackage.Literals.IMPORT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OclPackage.Literals.IMPORT__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getImportAccess().getPackageEPackageSTRINGTerminalRuleCall_1_0_1(), semanticObject.eGet(OclPackage.Literals.IMPORT__PACKAGE, false));
		feeder.accept(grammarAccess.getImportAccess().getNameIDTerminalRuleCall_3_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     IntOpCallExp returns IntOpCallExp
	 *
	 * Constraint:
	 *     (args+=MulOpCallExp (operationNames+=INTOP args+=MulOpCallExp)*)
	 * </pre>
	 */
	protected void sequence_IntOpCallExp(ISerializationContext context, IntOpCallExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Primary_OclExpression returns IntegerLiteralExp
	 *     NumericLiteralExp returns IntegerLiteralExp
	 *     IntegerLiteralExp returns IntegerLiteralExp
	 *
	 * Constraint:
	 *     integerSymbol=INT
	 * </pre>
	 */
	protected void sequence_IntegerLiteralExp(ISerializationContext context, IntegerLiteralExp semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OclPackage.Literals.INTEGER_LITERAL_EXP__INTEGER_SYMBOL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OclPackage.Literals.INTEGER_LITERAL_EXP__INTEGER_SYMBOL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIntegerLiteralExpAccess().getIntegerSymbolINTTerminalRuleCall_1_0(), semanticObject.getIntegerSymbol());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     OclTypeLiteral returns IntegerType
	 *     Primitive returns IntegerType
	 *     NumericType returns IntegerType
	 *     IntegerType returns IntegerType
	 *
	 * Constraint:
	 *     {IntegerType}
	 * </pre>
	 */
	protected void sequence_IntegerType(ISerializationContext context, IntegerType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     PropertyCall returns IterateExp
	 *     IterateExp returns IterateExp
	 *
	 * Constraint:
	 *     (iterators+=Iterator iterators+=Iterator* result=LocalVariable body=OclExpression)
	 * </pre>
	 */
	protected void sequence_IterateExp(ISerializationContext context, IterateExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     PropertyCall returns IteratorExp
	 *     IteratorExp returns IteratorExp
	 *
	 * Constraint:
	 *     (name=ID iterators+=Iterator iterators+=Iterator* body=OclExpression)
	 * </pre>
	 */
	protected void sequence_IteratorExp(ISerializationContext context, IteratorExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Auxiliary returns Iterator
	 *     Iterator returns Iterator
	 *
	 * Constraint:
	 *     (name=ID type=OclTypeLiteral?)
	 * </pre>
	 */
	protected void sequence_Iterator(ISerializationContext context, Iterator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     OclExpression returns LetExp
	 *     LetExp returns LetExp
	 *
	 * Constraint:
	 *     (variable=LocalVariable in_=OclExpression)
	 * </pre>
	 */
	protected void sequence_LetExp(ISerializationContext context, LetExp semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OclPackage.Literals.LET_EXP__VARIABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OclPackage.Literals.LET_EXP__VARIABLE));
			if (transientValues.isValueTransient(semanticObject, OclPackage.Literals.LET_EXP__IN_) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OclPackage.Literals.LET_EXP__IN_));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLetExpAccess().getVariableLocalVariableParserRuleCall_1_0(), semanticObject.getVariable());
		feeder.accept(grammarAccess.getLetExpAccess().getIn_OclExpressionParserRuleCall_3_0(), semanticObject.getIn_());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Auxiliary returns LocalVariable
	 *     LocalVariable returns LocalVariable
	 *
	 * Constraint:
	 *     (name=ID type=OclTypeLiteral? initExpression=OclExpression)
	 * </pre>
	 */
	protected void sequence_LocalVariable(ISerializationContext context, LocalVariable semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     MapElement returns MapElement
	 *
	 * Constraint:
	 *     (key=OclExpression value=OclExpression)
	 * </pre>
	 */
	protected void sequence_MapElement(ISerializationContext context, MapElement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OclPackage.Literals.MAP_ELEMENT__KEY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OclPackage.Literals.MAP_ELEMENT__KEY));
			if (transientValues.isValueTransient(semanticObject, OclPackage.Literals.MAP_ELEMENT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OclPackage.Literals.MAP_ELEMENT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMapElementAccess().getKeyOclExpressionParserRuleCall_1_0(), semanticObject.getKey());
		feeder.accept(grammarAccess.getMapElementAccess().getValueOclExpressionParserRuleCall_3_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Primary_OclExpression returns MapLiteralExp
	 *     MapLiteralExp returns MapLiteralExp
	 *
	 * Constraint:
	 *     (elements+=MapElement elements+=MapElement*)?
	 * </pre>
	 */
	protected void sequence_MapLiteralExp(ISerializationContext context, MapLiteralExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     OclTypeLiteral returns MapType
	 *     MapType returns MapType
	 *
	 * Constraint:
	 *     (keyType=OclTypeLiteral valueType=OclTypeLiteral)
	 * </pre>
	 */
	protected void sequence_MapType(ISerializationContext context, MapType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OclPackage.Literals.MAP_TYPE__KEY_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OclPackage.Literals.MAP_TYPE__KEY_TYPE));
			if (transientValues.isValueTransient(semanticObject, OclPackage.Literals.MAP_TYPE__VALUE_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OclPackage.Literals.MAP_TYPE__VALUE_TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMapTypeAccess().getKeyTypeOclTypeLiteralParserRuleCall_2_0(), semanticObject.getKeyType());
		feeder.accept(grammarAccess.getMapTypeAccess().getValueTypeOclTypeLiteralParserRuleCall_4_0(), semanticObject.getValueType());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Module returns Module
	 *
	 * Constraint:
	 *     (imports+=Import+ contextlessFeatures+=OclFeatureDefinition* contextBlocks+=OclContextBlock+)
	 * </pre>
	 */
	protected void sequence_Module(ISerializationContext context, fr.enseeiht.ocl.xtext.ocl.Module semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     MulOpCallExp returns MulOpCallExp
	 *
	 * Constraint:
	 *     (args+=NotOpCallExp (operationNames+=MULOP args+=NotOpCallExp)*)
	 * </pre>
	 */
	protected void sequence_MulOpCallExp(ISerializationContext context, MulOpCallExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     PropertyCall returns NavigationOrAttributeCall
	 *     NavigationOrAttributeCall returns NavigationOrAttributeCall
	 *
	 * Constraint:
	 *     (name=STRING | name=ID)
	 * </pre>
	 */
	protected void sequence_NavigationOrAttributeCall(ISerializationContext context, NavigationOrAttributeCall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     NotOpCallExp returns NotOpCallExp
	 *
	 * Constraint:
	 *     (operationName=UNARYOP source=NotOpCallExp)
	 * </pre>
	 */
	protected void sequence_NotOpCallExp(ISerializationContext context, NotOpCallExp semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OclPackage.Literals.NOT_OP_CALL_EXP__OPERATION_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OclPackage.Literals.NOT_OP_CALL_EXP__OPERATION_NAME));
			if (transientValues.isValueTransient(semanticObject, OclPackage.Literals.NOT_OP_CALL_EXP__SOURCE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OclPackage.Literals.NOT_OP_CALL_EXP__SOURCE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNotOpCallExpAccess().getOperationNameUNARYOPParserRuleCall_0_0_0(), semanticObject.getOperationName());
		feeder.accept(grammarAccess.getNotOpCallExpAccess().getSourceNotOpCallExpParserRuleCall_0_1_0(), semanticObject.getSource());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Primary_OclExpression returns NullLiteralExp
	 *     NullLiteralExp returns NullLiteralExp
	 *
	 * Constraint:
	 *     {NullLiteralExp}
	 * </pre>
	 */
	protected void sequence_NullLiteralExp(ISerializationContext context, NullLiteralExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     OclTypeLiteral returns OclAnyType
	 *     OclAnyType returns OclAnyType
	 *
	 * Constraint:
	 *     {OclAnyType}
	 * </pre>
	 */
	protected void sequence_OclAnyType(ISerializationContext context, OclAnyType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     OclContextBlock returns OclContextBlock
	 *
	 * Constraint:
	 *     (ecoreTypes=[Import|ID] class=[EClass|QualifiedName] (members+=OclFeatureDefinition | members+=OclInvariant)+)
	 * </pre>
	 */
	protected void sequence_OclContextBlock(ISerializationContext context, OclContextBlock semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     OclFeatureDefinition returns OclFeatureDefinition
	 *
	 * Constraint:
	 *     (feature=Attribute | feature=Operation)
	 * </pre>
	 */
	protected void sequence_OclFeatureDefinition(ISerializationContext context, OclFeatureDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     OclInvariant returns OclInvariant
	 *
	 * Constraint:
	 *     (name=ID body=OclExpression)
	 * </pre>
	 */
	protected void sequence_OclInvariant(ISerializationContext context, OclInvariant semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OclPackage.Literals.OCL_INVARIANT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OclPackage.Literals.OCL_INVARIANT__NAME));
			if (transientValues.isValueTransient(semanticObject, OclPackage.Literals.OCL_INVARIANT__BODY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OclPackage.Literals.OCL_INVARIANT__BODY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOclInvariantAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getOclInvariantAccess().getBodyOclExpressionParserRuleCall_3_0(), semanticObject.getBody());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     OclTypeLiteral returns OclModelElementClass
	 *     OclModelElementClass returns OclModelElementClass
	 *
	 * Constraint:
	 *     (model=[Import|ID] name=ID)
	 * </pre>
	 */
	protected void sequence_OclModelElementClass(ISerializationContext context, OclModelElementClass semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OclPackage.Literals.OCL_MODEL_ELEMENT_CLASS__MODEL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OclPackage.Literals.OCL_MODEL_ELEMENT_CLASS__MODEL));
			if (transientValues.isValueTransient(semanticObject, OclPackage.Literals.OCL_MODEL_ELEMENT_CLASS__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OclPackage.Literals.OCL_MODEL_ELEMENT_CLASS__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOclModelElementClassAccess().getModelImportIDTerminalRuleCall_0_0_1(), semanticObject.eGet(OclPackage.Literals.OCL_MODEL_ELEMENT_CLASS__MODEL, false));
		feeder.accept(grammarAccess.getOclModelElementClassAccess().getNameIDTerminalRuleCall_2_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     OclModelElementExp returns OclModelElementExp
	 *     Primary_OclExpression returns OclModelElementExp
	 *
	 * Constraint:
	 *     (model=[Import|ID] name=ID)
	 * </pre>
	 */
	protected void sequence_OclModelElementExp(ISerializationContext context, OclModelElementExp semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OclPackage.Literals.OCL_MODEL_ELEMENT_EXP__MODEL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OclPackage.Literals.OCL_MODEL_ELEMENT_EXP__MODEL));
			if (transientValues.isValueTransient(semanticObject, OclPackage.Literals.OCL_MODEL_ELEMENT_EXP__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OclPackage.Literals.OCL_MODEL_ELEMENT_EXP__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOclModelElementExpAccess().getModelImportIDTerminalRuleCall_0_0_1(), semanticObject.eGet(OclPackage.Literals.OCL_MODEL_ELEMENT_EXP__MODEL, false));
		feeder.accept(grammarAccess.getOclModelElementExpAccess().getNameIDTerminalRuleCall_2_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     OclTypeLiteral returns OclVoidType
	 *     OclVoidType returns OclVoidType
	 *
	 * Constraint:
	 *     {OclVoidType}
	 * </pre>
	 */
	protected void sequence_OclVoidType(ISerializationContext context, OclVoidType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     PropertyCall returns OperationCall
	 *     OperationCall returns OperationCall
	 *
	 * Constraint:
	 *     (operationName=ID (arguments+=OclExpression arguments+=OclExpression*)?)
	 * </pre>
	 */
	protected void sequence_OperationCall(ISerializationContext context, OperationCall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Operation returns Operation
	 *
	 * Constraint:
	 *     (name=ID (parameters+=Parameter parameters+=Parameter*)? returnType=OclTypeLiteral body=OclExpression)
	 * </pre>
	 */
	protected void sequence_Operation(ISerializationContext context, Operation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     OclExpression returns OperatorCallExp
	 *     OperatorCallExp returns OperatorCallExp
	 *
	 * Constraint:
	 *     (args+=EqOpCallExp (operationNames+=BOOLOP args+=EqOpCallExp)*)
	 * </pre>
	 */
	protected void sequence_OperatorCallExp(ISerializationContext context, OperatorCallExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Primary_OclExpression returns OrderedSetLiteralExp
	 *     OrderedSetLiteralExp returns OrderedSetLiteralExp
	 *
	 * Constraint:
	 *     (elements+=OclExpression elements+=OclExpression*)?
	 * </pre>
	 */
	protected void sequence_OrderedSetLiteralExp(ISerializationContext context, OrderedSetLiteralExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     OclTypeLiteral returns OrderedSetType
	 *     CollectionTypeLiteral returns OrderedSetType
	 *     OrderedSetType returns OrderedSetType
	 *
	 * Constraint:
	 *     elementType=OclTypeLiteral
	 * </pre>
	 */
	protected void sequence_OrderedSetType(ISerializationContext context, OrderedSetType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OclPackage.Literals.COLLECTION_TYPE_LITERAL__ELEMENT_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OclPackage.Literals.COLLECTION_TYPE_LITERAL__ELEMENT_TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOrderedSetTypeAccess().getElementTypeOclTypeLiteralParserRuleCall_2_0(), semanticObject.getElementType());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Parameter returns Parameter
	 *     Auxiliary returns Parameter
	 *
	 * Constraint:
	 *     (name=ID type=OclTypeLiteral)
	 * </pre>
	 */
	protected void sequence_Parameter(ISerializationContext context, fr.enseeiht.ocl.xtext.ocl.Parameter semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OclPackage.Literals.AUXILIARY__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OclPackage.Literals.AUXILIARY__NAME));
			if (transientValues.isValueTransient(semanticObject, OclPackage.Literals.AUXILIARY__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OclPackage.Literals.AUXILIARY__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getParameterAccess().getNameIDTerminalRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getParameterAccess().getTypeOclTypeLiteralParserRuleCall_2_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     NotOpCallExp returns PropertyCallExp
	 *     PropertyCallExp returns PropertyCallExp
	 *
	 * Constraint:
	 *     (source=Primary_OclExpression calls+=PropertyCall*)
	 * </pre>
	 */
	protected void sequence_PropertyCallExp(ISerializationContext context, PropertyCallExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Primary_OclExpression returns RealLiteralExp
	 *     NumericLiteralExp returns RealLiteralExp
	 *     RealLiteralExp returns RealLiteralExp
	 *
	 * Constraint:
	 *     realSymbol=DOUBLE
	 * </pre>
	 */
	protected void sequence_RealLiteralExp(ISerializationContext context, RealLiteralExp semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OclPackage.Literals.REAL_LITERAL_EXP__REAL_SYMBOL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OclPackage.Literals.REAL_LITERAL_EXP__REAL_SYMBOL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRealLiteralExpAccess().getRealSymbolDOUBLETerminalRuleCall_0(), semanticObject.getRealSymbol());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     OclTypeLiteral returns RealType
	 *     Primitive returns RealType
	 *     NumericType returns RealType
	 *     RealType returns RealType
	 *
	 * Constraint:
	 *     {RealType}
	 * </pre>
	 */
	protected void sequence_RealType(ISerializationContext context, RealType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     RelOpCallExp returns RelOpCallExp
	 *
	 * Constraint:
	 *     (args+=AddOpCallExp (operationNames+=RELOP args+=AddOpCallExp)?)
	 * </pre>
	 */
	protected void sequence_RelOpCallExp(ISerializationContext context, RelOpCallExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Primary_OclExpression returns SelfLiteralExp
	 *     SelfLiteralExp returns SelfLiteralExp
	 *
	 * Constraint:
	 *     {SelfLiteralExp}
	 * </pre>
	 */
	protected void sequence_SelfLiteralExp(ISerializationContext context, SelfLiteralExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Primary_OclExpression returns SequenceLiteralExp
	 *     SequenceLiteralExp returns SequenceLiteralExp
	 *
	 * Constraint:
	 *     (elements+=OclExpression elements+=OclExpression*)?
	 * </pre>
	 */
	protected void sequence_SequenceLiteralExp(ISerializationContext context, SequenceLiteralExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     OclTypeLiteral returns SequenceType
	 *     CollectionTypeLiteral returns SequenceType
	 *     SequenceType returns SequenceType
	 *
	 * Constraint:
	 *     elementType=OclTypeLiteral
	 * </pre>
	 */
	protected void sequence_SequenceType(ISerializationContext context, SequenceType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OclPackage.Literals.COLLECTION_TYPE_LITERAL__ELEMENT_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OclPackage.Literals.COLLECTION_TYPE_LITERAL__ELEMENT_TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSequenceTypeAccess().getElementTypeOclTypeLiteralParserRuleCall_2_0(), semanticObject.getElementType());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Primary_OclExpression returns SetLiteralExp
	 *     SetLiteralExp returns SetLiteralExp
	 *
	 * Constraint:
	 *     (elements+=OclExpression elements+=OclExpression*)?
	 * </pre>
	 */
	protected void sequence_SetLiteralExp(ISerializationContext context, SetLiteralExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     OclTypeLiteral returns SetType
	 *     CollectionTypeLiteral returns SetType
	 *     SetType returns SetType
	 *
	 * Constraint:
	 *     elementType=OclTypeLiteral
	 * </pre>
	 */
	protected void sequence_SetType(ISerializationContext context, SetType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OclPackage.Literals.COLLECTION_TYPE_LITERAL__ELEMENT_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OclPackage.Literals.COLLECTION_TYPE_LITERAL__ELEMENT_TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSetTypeAccess().getElementTypeOclTypeLiteralParserRuleCall_2_0(), semanticObject.getElementType());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Primary_OclExpression returns StringLiteralExp
	 *     StringLiteralExp returns StringLiteralExp
	 *
	 * Constraint:
	 *     stringSymbol=STRING
	 * </pre>
	 */
	protected void sequence_StringLiteralExp(ISerializationContext context, StringLiteralExp semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OclPackage.Literals.STRING_LITERAL_EXP__STRING_SYMBOL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OclPackage.Literals.STRING_LITERAL_EXP__STRING_SYMBOL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStringLiteralExpAccess().getStringSymbolSTRINGTerminalRuleCall_1_0(), semanticObject.getStringSymbol());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     OclTypeLiteral returns StringType
	 *     Primitive returns StringType
	 *     StringType returns StringType
	 *
	 * Constraint:
	 *     {StringType}
	 * </pre>
	 */
	protected void sequence_StringType(ISerializationContext context, StringType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Primary_OclExpression returns TupleLiteralExp
	 *     TupleLiteralExp returns TupleLiteralExp
	 *
	 * Constraint:
	 *     (tuplePart+=TuplePart tuplePart+=TuplePart*)?
	 * </pre>
	 */
	protected void sequence_TupleLiteralExp(ISerializationContext context, TupleLiteralExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     TuplePart returns TuplePart
	 *
	 * Constraint:
	 *     (varName=ID type=OclTypeLiteral? initExpression=OclExpression)
	 * </pre>
	 */
	protected void sequence_TuplePart(ISerializationContext context, TuplePart semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     TupleTypeAttribute returns TupleTypeAttribute
	 *
	 * Constraint:
	 *     (name=ID type=OclTypeLiteral)
	 * </pre>
	 */
	protected void sequence_TupleTypeAttribute(ISerializationContext context, TupleTypeAttribute semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OclPackage.Literals.TUPLE_TYPE_ATTRIBUTE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OclPackage.Literals.TUPLE_TYPE_ATTRIBUTE__NAME));
			if (transientValues.isValueTransient(semanticObject, OclPackage.Literals.TUPLE_TYPE_ATTRIBUTE__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OclPackage.Literals.TUPLE_TYPE_ATTRIBUTE__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTupleTypeAttributeAccess().getNameIDTerminalRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getTupleTypeAttributeAccess().getTypeOclTypeLiteralParserRuleCall_2_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     OclTypeLiteral returns TupleType
	 *     TupleType returns TupleType
	 *
	 * Constraint:
	 *     (attributes+=TupleTypeAttribute attributes+=TupleTypeAttribute*)?
	 * </pre>
	 */
	protected void sequence_TupleType(ISerializationContext context, TupleType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Primary_OclExpression returns VariableExp
	 *     VariableExp returns VariableExp
	 *
	 * Constraint:
	 *     referredVariable=[Auxiliary|ID]
	 * </pre>
	 */
	protected void sequence_VariableExp(ISerializationContext context, VariableExp semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OclPackage.Literals.VARIABLE_EXP__REFERRED_VARIABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OclPackage.Literals.VARIABLE_EXP__REFERRED_VARIABLE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVariableExpAccess().getReferredVariableAuxiliaryIDTerminalRuleCall_0_1(), semanticObject.eGet(OclPackage.Literals.VARIABLE_EXP__REFERRED_VARIABLE, false));
		feeder.finish();
	}
	
	
}
