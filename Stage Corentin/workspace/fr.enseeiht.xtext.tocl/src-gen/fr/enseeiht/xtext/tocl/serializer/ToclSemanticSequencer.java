/*
 * generated by Xtext 2.32.0
 */
package fr.enseeiht.xtext.tocl.serializer;

import com.google.inject.Inject;
import fr.enseeiht.xtext.tocl.services.ToclGrammarAccess;
import fr.enseeiht.xtext.tocl.tocl.AddOpCallExp;
import fr.enseeiht.xtext.tocl.tocl.Attribute;
import fr.enseeiht.xtext.tocl.tocl.BagExp;
import fr.enseeiht.xtext.tocl.tocl.BagType;
import fr.enseeiht.xtext.tocl.tocl.BoolOpCallExp;
import fr.enseeiht.xtext.tocl.tocl.BooleanExp;
import fr.enseeiht.xtext.tocl.tocl.BooleanType;
import fr.enseeiht.xtext.tocl.tocl.BraceExp;
import fr.enseeiht.xtext.tocl.tocl.CollectionOperationCall;
import fr.enseeiht.xtext.tocl.tocl.EnumLiteralExp;
import fr.enseeiht.xtext.tocl.tocl.EqOpCallExp;
import fr.enseeiht.xtext.tocl.tocl.IfExp;
import fr.enseeiht.xtext.tocl.tocl.Import;
import fr.enseeiht.xtext.tocl.tocl.IntOpCallExp;
import fr.enseeiht.xtext.tocl.tocl.IntegerExp;
import fr.enseeiht.xtext.tocl.tocl.IntegerType;
import fr.enseeiht.xtext.tocl.tocl.IterateExp;
import fr.enseeiht.xtext.tocl.tocl.Iterator;
import fr.enseeiht.xtext.tocl.tocl.IteratorExp;
import fr.enseeiht.xtext.tocl.tocl.LetExp;
import fr.enseeiht.xtext.tocl.tocl.LocalVariable;
import fr.enseeiht.xtext.tocl.tocl.MapElement;
import fr.enseeiht.xtext.tocl.tocl.MapExp;
import fr.enseeiht.xtext.tocl.tocl.MapType;
import fr.enseeiht.xtext.tocl.tocl.MulOpCallExp;
import fr.enseeiht.xtext.tocl.tocl.NavigationOrAttributeCall;
import fr.enseeiht.xtext.tocl.tocl.OclAnyType;
import fr.enseeiht.xtext.tocl.tocl.OclFeatureDefinition;
import fr.enseeiht.xtext.tocl.tocl.OclInvariant;
import fr.enseeiht.xtext.tocl.tocl.OclModelElement;
import fr.enseeiht.xtext.tocl.tocl.OclModelElementExp;
import fr.enseeiht.xtext.tocl.tocl.OclType;
import fr.enseeiht.xtext.tocl.tocl.OclUndefinedExp;
import fr.enseeiht.xtext.tocl.tocl.Operation;
import fr.enseeiht.xtext.tocl.tocl.OperationCall;
import fr.enseeiht.xtext.tocl.tocl.OperatorCallExp;
import fr.enseeiht.xtext.tocl.tocl.OrderedSetExp;
import fr.enseeiht.xtext.tocl.tocl.OrderedSetType;
import fr.enseeiht.xtext.tocl.tocl.PropertyCallExp;
import fr.enseeiht.xtext.tocl.tocl.RealExp;
import fr.enseeiht.xtext.tocl.tocl.RealType;
import fr.enseeiht.xtext.tocl.tocl.RelOpCallExp;
import fr.enseeiht.xtext.tocl.tocl.SelfExp;
import fr.enseeiht.xtext.tocl.tocl.SequenceExp;
import fr.enseeiht.xtext.tocl.tocl.SequenceType;
import fr.enseeiht.xtext.tocl.tocl.SetExp;
import fr.enseeiht.xtext.tocl.tocl.SetType;
import fr.enseeiht.xtext.tocl.tocl.StringExp;
import fr.enseeiht.xtext.tocl.tocl.StringType;
import fr.enseeiht.xtext.tocl.tocl.SuperExp;
import fr.enseeiht.xtext.tocl.tocl.ToclPackage;
import fr.enseeiht.xtext.tocl.tocl.TupleExp;
import fr.enseeiht.xtext.tocl.tocl.TuplePart;
import fr.enseeiht.xtext.tocl.tocl.TupleType;
import fr.enseeiht.xtext.tocl.tocl.TupleTypeAttribute;
import fr.enseeiht.xtext.tocl.tocl.VariableDeclaration;
import fr.enseeiht.xtext.tocl.tocl.VariableExp;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class ToclSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private ToclGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == ToclPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case ToclPackage.ADD_OP_CALL_EXP:
				sequence_AddOpCallExp(context, (AddOpCallExp) semanticObject); 
				return; 
			case ToclPackage.ATTRIBUTE:
				sequence_Attribute(context, (Attribute) semanticObject); 
				return; 
			case ToclPackage.BAG_EXP:
				sequence_BagExp(context, (BagExp) semanticObject); 
				return; 
			case ToclPackage.BAG_TYPE:
				sequence_BagType(context, (BagType) semanticObject); 
				return; 
			case ToclPackage.BOOL_OP_CALL_EXP:
				sequence_BoolOpCallExp(context, (BoolOpCallExp) semanticObject); 
				return; 
			case ToclPackage.BOOLEAN_EXP:
				sequence_BooleanExp(context, (BooleanExp) semanticObject); 
				return; 
			case ToclPackage.BOOLEAN_TYPE:
				sequence_BooleanType(context, (BooleanType) semanticObject); 
				return; 
			case ToclPackage.BRACE_EXP:
				sequence_BraceExp(context, (BraceExp) semanticObject); 
				return; 
			case ToclPackage.COLLECTION_OPERATION_CALL:
				sequence_CollectionOperationCall(context, (CollectionOperationCall) semanticObject); 
				return; 
			case ToclPackage.ENUM_LITERAL_EXP:
				sequence_EnumLiteralExp(context, (EnumLiteralExp) semanticObject); 
				return; 
			case ToclPackage.EQ_OP_CALL_EXP:
				sequence_EqOpCallExp(context, (EqOpCallExp) semanticObject); 
				return; 
			case ToclPackage.IF_EXP:
				sequence_IfExp(context, (IfExp) semanticObject); 
				return; 
			case ToclPackage.IMPORT:
				sequence_Import(context, (Import) semanticObject); 
				return; 
			case ToclPackage.INT_OP_CALL_EXP:
				sequence_IntOpCallExp(context, (IntOpCallExp) semanticObject); 
				return; 
			case ToclPackage.INTEGER_EXP:
				sequence_IntegerExp(context, (IntegerExp) semanticObject); 
				return; 
			case ToclPackage.INTEGER_TYPE:
				sequence_IntegerType(context, (IntegerType) semanticObject); 
				return; 
			case ToclPackage.ITERATE_EXP:
				sequence_IterateExp(context, (IterateExp) semanticObject); 
				return; 
			case ToclPackage.ITERATOR:
				sequence_Iterator(context, (Iterator) semanticObject); 
				return; 
			case ToclPackage.ITERATOR_EXP:
				sequence_IteratorExp(context, (IteratorExp) semanticObject); 
				return; 
			case ToclPackage.LET_EXP:
				sequence_LetExp(context, (LetExp) semanticObject); 
				return; 
			case ToclPackage.LOCAL_VARIABLE:
				sequence_LocalVariable(context, (LocalVariable) semanticObject); 
				return; 
			case ToclPackage.MAP_ELEMENT:
				sequence_MapElement(context, (MapElement) semanticObject); 
				return; 
			case ToclPackage.MAP_EXP:
				sequence_MapExp(context, (MapExp) semanticObject); 
				return; 
			case ToclPackage.MAP_TYPE:
				sequence_MapType(context, (MapType) semanticObject); 
				return; 
			case ToclPackage.MODULE:
				sequence_Module(context, (fr.enseeiht.xtext.tocl.tocl.Module) semanticObject); 
				return; 
			case ToclPackage.MUL_OP_CALL_EXP:
				sequence_MulOpCallExp(context, (MulOpCallExp) semanticObject); 
				return; 
			case ToclPackage.NAVIGATION_OR_ATTRIBUTE_CALL:
				sequence_NavigationOrAttributeCall(context, (NavigationOrAttributeCall) semanticObject); 
				return; 
			case ToclPackage.OCL_ANY_TYPE:
				sequence_OclAnyType(context, (OclAnyType) semanticObject); 
				return; 
			case ToclPackage.OCL_FEATURE_DEFINITION:
				sequence_OclFeatureDefinition(context, (OclFeatureDefinition) semanticObject); 
				return; 
			case ToclPackage.OCL_INVARIANT:
				sequence_OclInvariant(context, (OclInvariant) semanticObject); 
				return; 
			case ToclPackage.OCL_MODEL_ELEMENT:
				sequence_OclModelElement(context, (OclModelElement) semanticObject); 
				return; 
			case ToclPackage.OCL_MODEL_ELEMENT_EXP:
				sequence_OclModelElementExp(context, (OclModelElementExp) semanticObject); 
				return; 
			case ToclPackage.OCL_TYPE:
				sequence_OclType_abstractContents(context, (OclType) semanticObject); 
				return; 
			case ToclPackage.OCL_UNDEFINED_EXP:
				sequence_OclUndefinedExp(context, (OclUndefinedExp) semanticObject); 
				return; 
			case ToclPackage.OPERATION:
				sequence_Operation(context, (Operation) semanticObject); 
				return; 
			case ToclPackage.OPERATION_CALL:
				sequence_OperationCall(context, (OperationCall) semanticObject); 
				return; 
			case ToclPackage.OPERATOR_CALL_EXP:
				if (rule == grammarAccess.getBoolOpCallExpRule()
						|| action == grammarAccess.getBoolOpCallExpAccess().getBoolOpCallExpSourceAction_1_0_0()
						|| rule == grammarAccess.getEqOpCallExpRule()
						|| action == grammarAccess.getEqOpCallExpAccess().getEqOpCallExpSourceAction_1_0_0()
						|| rule == grammarAccess.getRelOpCallExpRule()
						|| action == grammarAccess.getRelOpCallExpAccess().getRelOpCallExpSourceAction_1_0_0()
						|| rule == grammarAccess.getAddOpCallExpRule()
						|| action == grammarAccess.getAddOpCallExpAccess().getAddOpCallExpSourceAction_1_0_0()
						|| rule == grammarAccess.getIntOpCallExpRule()
						|| action == grammarAccess.getIntOpCallExpAccess().getIntOpCallExpSourceAction_1_0_0()
						|| rule == grammarAccess.getMulOpCallExpRule()
						|| action == grammarAccess.getMulOpCallExpAccess().getMulOpCallExpSourceAction_1_0_0()
						|| rule == grammarAccess.getNotOpCallExpRule()) {
					sequence_NotOpCallExp(context, (OperatorCallExp) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getOclExpressionRule()
						|| rule == grammarAccess.getOperatorCallExpRule()
						|| action == grammarAccess.getOperatorCallExpAccess().getOperatorCallExpSourceAction_1_0()) {
					sequence_NotOpCallExp_OperatorCallExp(context, (OperatorCallExp) semanticObject); 
					return; 
				}
				else break;
			case ToclPackage.ORDERED_SET_EXP:
				sequence_OrderedSetExp(context, (OrderedSetExp) semanticObject); 
				return; 
			case ToclPackage.ORDERED_SET_TYPE:
				sequence_OrderedSetType(context, (OrderedSetType) semanticObject); 
				return; 
			case ToclPackage.PARAMETER:
				sequence_Parameter(context, (fr.enseeiht.xtext.tocl.tocl.Parameter) semanticObject); 
				return; 
			case ToclPackage.PROPERTY_CALL_EXP:
				sequence_PropertyCallExp(context, (PropertyCallExp) semanticObject); 
				return; 
			case ToclPackage.REAL_EXP:
				sequence_RealExp(context, (RealExp) semanticObject); 
				return; 
			case ToclPackage.REAL_TYPE:
				sequence_RealType(context, (RealType) semanticObject); 
				return; 
			case ToclPackage.REL_OP_CALL_EXP:
				sequence_RelOpCallExp(context, (RelOpCallExp) semanticObject); 
				return; 
			case ToclPackage.SELF_EXP:
				sequence_SelfExp(context, (SelfExp) semanticObject); 
				return; 
			case ToclPackage.SEQUENCE_EXP:
				sequence_SequenceExp(context, (SequenceExp) semanticObject); 
				return; 
			case ToclPackage.SEQUENCE_TYPE:
				sequence_SequenceType(context, (SequenceType) semanticObject); 
				return; 
			case ToclPackage.SET_EXP:
				sequence_SetExp(context, (SetExp) semanticObject); 
				return; 
			case ToclPackage.SET_TYPE:
				sequence_SetType(context, (SetType) semanticObject); 
				return; 
			case ToclPackage.STRING_EXP:
				sequence_StringExp(context, (StringExp) semanticObject); 
				return; 
			case ToclPackage.STRING_TYPE:
				sequence_StringType(context, (StringType) semanticObject); 
				return; 
			case ToclPackage.SUPER_EXP:
				sequence_SuperExp(context, (SuperExp) semanticObject); 
				return; 
			case ToclPackage.TUPLE_EXP:
				sequence_TupleExp(context, (TupleExp) semanticObject); 
				return; 
			case ToclPackage.TUPLE_PART:
				sequence_TuplePart(context, (TuplePart) semanticObject); 
				return; 
			case ToclPackage.TUPLE_TYPE:
				sequence_TupleType(context, (TupleType) semanticObject); 
				return; 
			case ToclPackage.TUPLE_TYPE_ATTRIBUTE:
				sequence_TupleTypeAttribute(context, (TupleTypeAttribute) semanticObject); 
				return; 
			case ToclPackage.VARIABLE_DECLARATION:
				sequence_VariableDeclaration(context, (VariableDeclaration) semanticObject); 
				return; 
			case ToclPackage.VARIABLE_EXP:
				sequence_VariableExp(context, (VariableExp) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * <pre>
	 * Contexts:
	 *     OclExpression returns AddOpCallExp
	 *     OperatorCallExp returns AddOpCallExp
	 *     OperatorCallExp.OperatorCallExp_1_0 returns AddOpCallExp
	 *     BoolOpCallExp returns AddOpCallExp
	 *     BoolOpCallExp.BoolOpCallExp_1_0_0 returns AddOpCallExp
	 *     EqOpCallExp returns AddOpCallExp
	 *     EqOpCallExp.EqOpCallExp_1_0_0 returns AddOpCallExp
	 *     RelOpCallExp returns AddOpCallExp
	 *     RelOpCallExp.RelOpCallExp_1_0_0 returns AddOpCallExp
	 *     AddOpCallExp returns AddOpCallExp
	 *     AddOpCallExp.AddOpCallExp_1_0_0 returns AddOpCallExp
	 *
	 * Constraint:
	 *     (source=AddOpCallExp_AddOpCallExp_1_0_0 operationName=ADDOP argument=IntOpCallExp)
	 * </pre>
	 */
	protected void sequence_AddOpCallExp(ISerializationContext context, AddOpCallExp semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ToclPackage.Literals.OPERATOR_CALL_EXP__SOURCE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ToclPackage.Literals.OPERATOR_CALL_EXP__SOURCE));
			if (transientValues.isValueTransient(semanticObject, ToclPackage.Literals.OPERATOR_CALL_EXP__OPERATION_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ToclPackage.Literals.OPERATOR_CALL_EXP__OPERATION_NAME));
			if (transientValues.isValueTransient(semanticObject, ToclPackage.Literals.OPERATOR_CALL_EXP__ARGUMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ToclPackage.Literals.OPERATOR_CALL_EXP__ARGUMENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAddOpCallExpAccess().getAddOpCallExpSourceAction_1_0_0(), semanticObject.getSource());
		feeder.accept(grammarAccess.getAddOpCallExpAccess().getOperationNameADDOPParserRuleCall_1_0_1_0(), semanticObject.getOperationName());
		feeder.accept(grammarAccess.getAddOpCallExpAccess().getArgumentIntOpCallExpParserRuleCall_1_1_0(), semanticObject.getArgument());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Attribute returns Attribute
	 *
	 * Constraint:
	 *     (name=ID type=OclType initExpression=OclExpression)
	 * </pre>
	 */
	protected void sequence_Attribute(ISerializationContext context, Attribute semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ToclPackage.Literals.ATTRIBUTE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ToclPackage.Literals.ATTRIBUTE__NAME));
			if (transientValues.isValueTransient(semanticObject, ToclPackage.Literals.ATTRIBUTE__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ToclPackage.Literals.ATTRIBUTE__TYPE));
			if (transientValues.isValueTransient(semanticObject, ToclPackage.Literals.ATTRIBUTE__INIT_EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ToclPackage.Literals.ATTRIBUTE__INIT_EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAttributeAccess().getNameIDTerminalRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getAttributeAccess().getTypeOclTypeParserRuleCall_2_0(), semanticObject.getType());
		feeder.accept(grammarAccess.getAttributeAccess().getInitExpressionOclExpressionParserRuleCall_4_0(), semanticObject.getInitExpression());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Primary_OclExpression returns BagExp
	 *     BagExp returns BagExp
	 *
	 * Constraint:
	 *     (elements+=OclExpression elements+=OclExpression*)?
	 * </pre>
	 */
	protected void sequence_BagExp(ISerializationContext context, BagExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     OclType returns BagType
	 *     CollectionType returns BagType
	 *     BagType returns BagType
	 *
	 * Constraint:
	 *     elementType=OclType
	 * </pre>
	 */
	protected void sequence_BagType(ISerializationContext context, BagType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ToclPackage.Literals.COLLECTION_TYPE__ELEMENT_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ToclPackage.Literals.COLLECTION_TYPE__ELEMENT_TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBagTypeAccess().getElementTypeOclTypeParserRuleCall_2_0(), semanticObject.getElementType());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     OclExpression returns BoolOpCallExp
	 *     OperatorCallExp returns BoolOpCallExp
	 *     OperatorCallExp.OperatorCallExp_1_0 returns BoolOpCallExp
	 *     BoolOpCallExp returns BoolOpCallExp
	 *     BoolOpCallExp.BoolOpCallExp_1_0_0 returns BoolOpCallExp
	 *
	 * Constraint:
	 *     (source=BoolOpCallExp_BoolOpCallExp_1_0_0 operationName=BOOLOP argument=EqOpCallExp)
	 * </pre>
	 */
	protected void sequence_BoolOpCallExp(ISerializationContext context, BoolOpCallExp semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ToclPackage.Literals.OPERATOR_CALL_EXP__SOURCE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ToclPackage.Literals.OPERATOR_CALL_EXP__SOURCE));
			if (transientValues.isValueTransient(semanticObject, ToclPackage.Literals.OPERATOR_CALL_EXP__OPERATION_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ToclPackage.Literals.OPERATOR_CALL_EXP__OPERATION_NAME));
			if (transientValues.isValueTransient(semanticObject, ToclPackage.Literals.OPERATOR_CALL_EXP__ARGUMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ToclPackage.Literals.OPERATOR_CALL_EXP__ARGUMENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBoolOpCallExpAccess().getBoolOpCallExpSourceAction_1_0_0(), semanticObject.getSource());
		feeder.accept(grammarAccess.getBoolOpCallExpAccess().getOperationNameBOOLOPParserRuleCall_1_0_1_0(), semanticObject.getOperationName());
		feeder.accept(grammarAccess.getBoolOpCallExpAccess().getArgumentEqOpCallExpParserRuleCall_1_1_0(), semanticObject.getArgument());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Primary_OclExpression returns BooleanExp
	 *     BooleanExp returns BooleanExp
	 *
	 * Constraint:
	 *     (booleanSymbol='true' | booleanSymbol='false')
	 * </pre>
	 */
	protected void sequence_BooleanExp(ISerializationContext context, BooleanExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     OclType returns BooleanType
	 *     Primitive returns BooleanType
	 *     BooleanType returns BooleanType
	 *
	 * Constraint:
	 *     {BooleanType}
	 * </pre>
	 */
	protected void sequence_BooleanType(ISerializationContext context, BooleanType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Primary_OclExpression returns BraceExp
	 *     BraceExp returns BraceExp
	 *
	 * Constraint:
	 *     exp=OclExpression
	 * </pre>
	 */
	protected void sequence_BraceExp(ISerializationContext context, BraceExp semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ToclPackage.Literals.BRACE_EXP__EXP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ToclPackage.Literals.BRACE_EXP__EXP));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBraceExpAccess().getExpOclExpressionParserRuleCall_1_0(), semanticObject.getExp());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     PropertyCall returns CollectionOperationCall
	 *     CollectionOperationCall returns CollectionOperationCall
	 *
	 * Constraint:
	 *     (operationName=ID (arguments+=OclExpression arguments+=OclExpression*)?)
	 * </pre>
	 */
	protected void sequence_CollectionOperationCall(ISerializationContext context, CollectionOperationCall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Primary_OclExpression returns EnumLiteralExp
	 *     EnumLiteralExp returns EnumLiteralExp
	 *
	 * Constraint:
	 *     (name=STRING | name=ID)
	 * </pre>
	 */
	protected void sequence_EnumLiteralExp(ISerializationContext context, EnumLiteralExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     OclExpression returns EqOpCallExp
	 *     OperatorCallExp returns EqOpCallExp
	 *     OperatorCallExp.OperatorCallExp_1_0 returns EqOpCallExp
	 *     BoolOpCallExp returns EqOpCallExp
	 *     BoolOpCallExp.BoolOpCallExp_1_0_0 returns EqOpCallExp
	 *     EqOpCallExp returns EqOpCallExp
	 *     EqOpCallExp.EqOpCallExp_1_0_0 returns EqOpCallExp
	 *
	 * Constraint:
	 *     (source=EqOpCallExp_EqOpCallExp_1_0_0 operationName=EQOP argument=RelOpCallExp)
	 * </pre>
	 */
	protected void sequence_EqOpCallExp(ISerializationContext context, EqOpCallExp semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ToclPackage.Literals.OPERATOR_CALL_EXP__SOURCE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ToclPackage.Literals.OPERATOR_CALL_EXP__SOURCE));
			if (transientValues.isValueTransient(semanticObject, ToclPackage.Literals.OPERATOR_CALL_EXP__OPERATION_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ToclPackage.Literals.OPERATOR_CALL_EXP__OPERATION_NAME));
			if (transientValues.isValueTransient(semanticObject, ToclPackage.Literals.OPERATOR_CALL_EXP__ARGUMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ToclPackage.Literals.OPERATOR_CALL_EXP__ARGUMENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEqOpCallExpAccess().getEqOpCallExpSourceAction_1_0_0(), semanticObject.getSource());
		feeder.accept(grammarAccess.getEqOpCallExpAccess().getOperationNameEQOPParserRuleCall_1_0_1_0(), semanticObject.getOperationName());
		feeder.accept(grammarAccess.getEqOpCallExpAccess().getArgumentRelOpCallExpParserRuleCall_1_1_0(), semanticObject.getArgument());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Primary_OclExpression returns IfExp
	 *     IfExp returns IfExp
	 *
	 * Constraint:
	 *     (condition=OclExpression thenExpression=OclExpression elseExpression=OclExpression)
	 * </pre>
	 */
	protected void sequence_IfExp(ISerializationContext context, IfExp semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ToclPackage.Literals.IF_EXP__CONDITION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ToclPackage.Literals.IF_EXP__CONDITION));
			if (transientValues.isValueTransient(semanticObject, ToclPackage.Literals.IF_EXP__THEN_EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ToclPackage.Literals.IF_EXP__THEN_EXPRESSION));
			if (transientValues.isValueTransient(semanticObject, ToclPackage.Literals.IF_EXP__ELSE_EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ToclPackage.Literals.IF_EXP__ELSE_EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIfExpAccess().getConditionOclExpressionParserRuleCall_1_0(), semanticObject.getCondition());
		feeder.accept(grammarAccess.getIfExpAccess().getThenExpressionOclExpressionParserRuleCall_3_0(), semanticObject.getThenExpression());
		feeder.accept(grammarAccess.getIfExpAccess().getElseExpressionOclExpressionParserRuleCall_5_0(), semanticObject.getElseExpression());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Import returns Import
	 *
	 * Constraint:
	 *     (package=[EPackage|STRING] name=ID)
	 * </pre>
	 */
	protected void sequence_Import(ISerializationContext context, Import semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ToclPackage.Literals.IMPORT__PACKAGE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ToclPackage.Literals.IMPORT__PACKAGE));
			if (transientValues.isValueTransient(semanticObject, ToclPackage.Literals.IMPORT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ToclPackage.Literals.IMPORT__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getImportAccess().getPackageEPackageSTRINGTerminalRuleCall_1_0_1(), semanticObject.eGet(ToclPackage.Literals.IMPORT__PACKAGE, false));
		feeder.accept(grammarAccess.getImportAccess().getNameIDTerminalRuleCall_3_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     OclExpression returns IntOpCallExp
	 *     OperatorCallExp returns IntOpCallExp
	 *     OperatorCallExp.OperatorCallExp_1_0 returns IntOpCallExp
	 *     BoolOpCallExp returns IntOpCallExp
	 *     BoolOpCallExp.BoolOpCallExp_1_0_0 returns IntOpCallExp
	 *     EqOpCallExp returns IntOpCallExp
	 *     EqOpCallExp.EqOpCallExp_1_0_0 returns IntOpCallExp
	 *     RelOpCallExp returns IntOpCallExp
	 *     RelOpCallExp.RelOpCallExp_1_0_0 returns IntOpCallExp
	 *     AddOpCallExp returns IntOpCallExp
	 *     AddOpCallExp.AddOpCallExp_1_0_0 returns IntOpCallExp
	 *     IntOpCallExp returns IntOpCallExp
	 *     IntOpCallExp.IntOpCallExp_1_0_0 returns IntOpCallExp
	 *
	 * Constraint:
	 *     (source=IntOpCallExp_IntOpCallExp_1_0_0 operationName=INTOP argument=MulOpCallExp)
	 * </pre>
	 */
	protected void sequence_IntOpCallExp(ISerializationContext context, IntOpCallExp semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ToclPackage.Literals.OPERATOR_CALL_EXP__SOURCE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ToclPackage.Literals.OPERATOR_CALL_EXP__SOURCE));
			if (transientValues.isValueTransient(semanticObject, ToclPackage.Literals.OPERATOR_CALL_EXP__OPERATION_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ToclPackage.Literals.OPERATOR_CALL_EXP__OPERATION_NAME));
			if (transientValues.isValueTransient(semanticObject, ToclPackage.Literals.OPERATOR_CALL_EXP__ARGUMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ToclPackage.Literals.OPERATOR_CALL_EXP__ARGUMENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIntOpCallExpAccess().getIntOpCallExpSourceAction_1_0_0(), semanticObject.getSource());
		feeder.accept(grammarAccess.getIntOpCallExpAccess().getOperationNameINTOPParserRuleCall_1_0_1_0(), semanticObject.getOperationName());
		feeder.accept(grammarAccess.getIntOpCallExpAccess().getArgumentMulOpCallExpParserRuleCall_1_1_0(), semanticObject.getArgument());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Primary_OclExpression returns IntegerExp
	 *     NumericExp returns IntegerExp
	 *     IntegerExp returns IntegerExp
	 *
	 * Constraint:
	 *     integerSymbol=INT
	 * </pre>
	 */
	protected void sequence_IntegerExp(ISerializationContext context, IntegerExp semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ToclPackage.Literals.INTEGER_EXP__INTEGER_SYMBOL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ToclPackage.Literals.INTEGER_EXP__INTEGER_SYMBOL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIntegerExpAccess().getIntegerSymbolINTTerminalRuleCall_1_0(), semanticObject.getIntegerSymbol());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     OclType returns IntegerType
	 *     Primitive returns IntegerType
	 *     NumericType returns IntegerType
	 *     IntegerType returns IntegerType
	 *
	 * Constraint:
	 *     {IntegerType}
	 * </pre>
	 */
	protected void sequence_IntegerType(ISerializationContext context, IntegerType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     PropertyCall returns IterateExp
	 *     IterateExp returns IterateExp
	 *
	 * Constraint:
	 *     (iterators+=Iterator iterators+=Iterator* result=LocalVariable body=OclExpression)
	 * </pre>
	 */
	protected void sequence_IterateExp(ISerializationContext context, IterateExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     PropertyCall returns IteratorExp
	 *     IteratorExp returns IteratorExp
	 *
	 * Constraint:
	 *     (name=ID iterators+=Iterator iterators+=Iterator* body=OclExpression)
	 * </pre>
	 */
	protected void sequence_IteratorExp(ISerializationContext context, IteratorExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Auxiliary returns Iterator
	 *     Iterator returns Iterator
	 *
	 * Constraint:
	 *     (name=ID type=OclType?)
	 * </pre>
	 */
	protected void sequence_Iterator(ISerializationContext context, Iterator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     OclExpression returns LetExp
	 *     LetExp returns LetExp
	 *
	 * Constraint:
	 *     (variable=LocalVariable in_=OclExpression)
	 * </pre>
	 */
	protected void sequence_LetExp(ISerializationContext context, LetExp semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ToclPackage.Literals.LET_EXP__VARIABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ToclPackage.Literals.LET_EXP__VARIABLE));
			if (transientValues.isValueTransient(semanticObject, ToclPackage.Literals.LET_EXP__IN_) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ToclPackage.Literals.LET_EXP__IN_));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLetExpAccess().getVariableLocalVariableParserRuleCall_1_0(), semanticObject.getVariable());
		feeder.accept(grammarAccess.getLetExpAccess().getIn_OclExpressionParserRuleCall_3_0(), semanticObject.getIn_());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Auxiliary returns LocalVariable
	 *     LocalVariable returns LocalVariable
	 *
	 * Constraint:
	 *     (name=ID type=OclType? initExpression=OclExpression)
	 * </pre>
	 */
	protected void sequence_LocalVariable(ISerializationContext context, LocalVariable semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     MapElement returns MapElement
	 *
	 * Constraint:
	 *     (key=OclExpression value=OclExpression)
	 * </pre>
	 */
	protected void sequence_MapElement(ISerializationContext context, MapElement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ToclPackage.Literals.MAP_ELEMENT__KEY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ToclPackage.Literals.MAP_ELEMENT__KEY));
			if (transientValues.isValueTransient(semanticObject, ToclPackage.Literals.MAP_ELEMENT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ToclPackage.Literals.MAP_ELEMENT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMapElementAccess().getKeyOclExpressionParserRuleCall_1_0(), semanticObject.getKey());
		feeder.accept(grammarAccess.getMapElementAccess().getValueOclExpressionParserRuleCall_3_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Primary_OclExpression returns MapExp
	 *     MapExp returns MapExp
	 *
	 * Constraint:
	 *     (elements+=MapElement elements+=MapElement*)?
	 * </pre>
	 */
	protected void sequence_MapExp(ISerializationContext context, MapExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     OclType returns MapType
	 *     MapType returns MapType
	 *
	 * Constraint:
	 *     (keyType=OclType valueType=OclType)
	 * </pre>
	 */
	protected void sequence_MapType(ISerializationContext context, MapType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ToclPackage.Literals.MAP_TYPE__KEY_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ToclPackage.Literals.MAP_TYPE__KEY_TYPE));
			if (transientValues.isValueTransient(semanticObject, ToclPackage.Literals.MAP_TYPE__VALUE_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ToclPackage.Literals.MAP_TYPE__VALUE_TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMapTypeAccess().getKeyTypeOclTypeParserRuleCall_2_0(), semanticObject.getKeyType());
		feeder.accept(grammarAccess.getMapTypeAccess().getValueTypeOclTypeParserRuleCall_4_0(), semanticObject.getValueType());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Module returns Module
	 *
	 * Constraint:
	 *     (name=ID imports+=Import elements+=ModuleElement+)
	 * </pre>
	 */
	protected void sequence_Module(ISerializationContext context, fr.enseeiht.xtext.tocl.tocl.Module semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     OclExpression returns MulOpCallExp
	 *     OperatorCallExp returns MulOpCallExp
	 *     OperatorCallExp.OperatorCallExp_1_0 returns MulOpCallExp
	 *     BoolOpCallExp returns MulOpCallExp
	 *     BoolOpCallExp.BoolOpCallExp_1_0_0 returns MulOpCallExp
	 *     EqOpCallExp returns MulOpCallExp
	 *     EqOpCallExp.EqOpCallExp_1_0_0 returns MulOpCallExp
	 *     RelOpCallExp returns MulOpCallExp
	 *     RelOpCallExp.RelOpCallExp_1_0_0 returns MulOpCallExp
	 *     AddOpCallExp returns MulOpCallExp
	 *     AddOpCallExp.AddOpCallExp_1_0_0 returns MulOpCallExp
	 *     IntOpCallExp returns MulOpCallExp
	 *     IntOpCallExp.IntOpCallExp_1_0_0 returns MulOpCallExp
	 *     MulOpCallExp returns MulOpCallExp
	 *     MulOpCallExp.MulOpCallExp_1_0_0 returns MulOpCallExp
	 *
	 * Constraint:
	 *     (source=MulOpCallExp_MulOpCallExp_1_0_0 operationName=MULOP argument=NotOpCallExp)
	 * </pre>
	 */
	protected void sequence_MulOpCallExp(ISerializationContext context, MulOpCallExp semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ToclPackage.Literals.OPERATOR_CALL_EXP__SOURCE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ToclPackage.Literals.OPERATOR_CALL_EXP__SOURCE));
			if (transientValues.isValueTransient(semanticObject, ToclPackage.Literals.OPERATOR_CALL_EXP__OPERATION_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ToclPackage.Literals.OPERATOR_CALL_EXP__OPERATION_NAME));
			if (transientValues.isValueTransient(semanticObject, ToclPackage.Literals.OPERATOR_CALL_EXP__ARGUMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ToclPackage.Literals.OPERATOR_CALL_EXP__ARGUMENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMulOpCallExpAccess().getMulOpCallExpSourceAction_1_0_0(), semanticObject.getSource());
		feeder.accept(grammarAccess.getMulOpCallExpAccess().getOperationNameMULOPParserRuleCall_1_0_1_0(), semanticObject.getOperationName());
		feeder.accept(grammarAccess.getMulOpCallExpAccess().getArgumentNotOpCallExpParserRuleCall_1_1_0(), semanticObject.getArgument());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     PropertyCall returns NavigationOrAttributeCall
	 *     NavigationOrAttributeCall returns NavigationOrAttributeCall
	 *
	 * Constraint:
	 *     (name=STRING | name=ID)
	 * </pre>
	 */
	protected void sequence_NavigationOrAttributeCall(ISerializationContext context, NavigationOrAttributeCall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     BoolOpCallExp returns OperatorCallExp
	 *     BoolOpCallExp.BoolOpCallExp_1_0_0 returns OperatorCallExp
	 *     EqOpCallExp returns OperatorCallExp
	 *     EqOpCallExp.EqOpCallExp_1_0_0 returns OperatorCallExp
	 *     RelOpCallExp returns OperatorCallExp
	 *     RelOpCallExp.RelOpCallExp_1_0_0 returns OperatorCallExp
	 *     AddOpCallExp returns OperatorCallExp
	 *     AddOpCallExp.AddOpCallExp_1_0_0 returns OperatorCallExp
	 *     IntOpCallExp returns OperatorCallExp
	 *     IntOpCallExp.IntOpCallExp_1_0_0 returns OperatorCallExp
	 *     MulOpCallExp returns OperatorCallExp
	 *     MulOpCallExp.MulOpCallExp_1_0_0 returns OperatorCallExp
	 *     NotOpCallExp returns OperatorCallExp
	 *
	 * Constraint:
	 *     (operationName=UnaryOP source=NotOpCallExp)
	 * </pre>
	 */
	protected void sequence_NotOpCallExp(ISerializationContext context, OperatorCallExp semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ToclPackage.Literals.OPERATOR_CALL_EXP__OPERATION_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ToclPackage.Literals.OPERATOR_CALL_EXP__OPERATION_NAME));
			if (transientValues.isValueTransient(semanticObject, ToclPackage.Literals.OPERATOR_CALL_EXP__SOURCE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ToclPackage.Literals.OPERATOR_CALL_EXP__SOURCE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNotOpCallExpAccess().getOperationNameUnaryOPParserRuleCall_0_0_0(), semanticObject.getOperationName());
		feeder.accept(grammarAccess.getNotOpCallExpAccess().getSourceNotOpCallExpParserRuleCall_0_1_0(), semanticObject.getSource());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     OclExpression returns OperatorCallExp
	 *     OperatorCallExp returns OperatorCallExp
	 *     OperatorCallExp.OperatorCallExp_1_0 returns OperatorCallExp
	 *
	 * Constraint:
	 *     ((source=OperatorCallExp_OperatorCallExp_1_0 operationName=TEMPBIOP argument=BoolOpCallExp) | (operationName=UnaryOP source=NotOpCallExp))
	 * </pre>
	 */
	protected void sequence_NotOpCallExp_OperatorCallExp(ISerializationContext context, OperatorCallExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     OclType returns OclAnyType
	 *     OclAnyType returns OclAnyType
	 *
	 * Constraint:
	 *     {OclAnyType}
	 * </pre>
	 */
	protected void sequence_OclAnyType(ISerializationContext context, OclAnyType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ModuleElement returns OclFeatureDefinition
	 *     OclModuleElement returns OclFeatureDefinition
	 *     OclFeatureDefinition returns OclFeatureDefinition
	 *
	 * Constraint:
	 *     ((ecoreTypes=[Import|ID] class=[EClass|QualifiedName])? (feature=Attribute | feature=Operation))
	 * </pre>
	 */
	protected void sequence_OclFeatureDefinition(ISerializationContext context, OclFeatureDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ModuleElement returns OclInvariant
	 *     OclModuleElement returns OclInvariant
	 *     OclInvariant returns OclInvariant
	 *
	 * Constraint:
	 *     ((ecoreTypes=[Import|ID] class=[EClass|QualifiedName])? name=ID body=OclExpression)
	 * </pre>
	 */
	protected void sequence_OclInvariant(ISerializationContext context, OclInvariant semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     OclModelElementExp returns OclModelElementExp
	 *     Primary_OclExpression returns OclModelElementExp
	 *
	 * Constraint:
	 *     (model=[Import|ID] name=ID)
	 * </pre>
	 */
	protected void sequence_OclModelElementExp(ISerializationContext context, OclModelElementExp semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ToclPackage.Literals.OCL_MODEL_ELEMENT_EXP__MODEL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ToclPackage.Literals.OCL_MODEL_ELEMENT_EXP__MODEL));
			if (transientValues.isValueTransient(semanticObject, ToclPackage.Literals.OCL_MODEL_ELEMENT_EXP__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ToclPackage.Literals.OCL_MODEL_ELEMENT_EXP__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOclModelElementExpAccess().getModelImportIDTerminalRuleCall_0_0_1(), semanticObject.eGet(ToclPackage.Literals.OCL_MODEL_ELEMENT_EXP__MODEL, false));
		feeder.accept(grammarAccess.getOclModelElementExpAccess().getNameIDTerminalRuleCall_2_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     OclType returns OclModelElement
	 *     OclModelElement returns OclModelElement
	 *
	 * Constraint:
	 *     (model=[Import|ID] name=ID)
	 * </pre>
	 */
	protected void sequence_OclModelElement(ISerializationContext context, OclModelElement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ToclPackage.Literals.OCL_MODEL_ELEMENT__MODEL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ToclPackage.Literals.OCL_MODEL_ELEMENT__MODEL));
			if (transientValues.isValueTransient(semanticObject, ToclPackage.Literals.OCL_MODEL_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ToclPackage.Literals.OCL_MODEL_ELEMENT__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOclModelElementAccess().getModelImportIDTerminalRuleCall_0_0_1(), semanticObject.eGet(ToclPackage.Literals.OCL_MODEL_ELEMENT__MODEL, false));
		feeder.accept(grammarAccess.getOclModelElementAccess().getNameIDTerminalRuleCall_2_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     OclType returns OclType
	 *     OclType_abstractContents returns OclType
	 *
	 * Constraint:
	 *     {OclType}
	 * </pre>
	 */
	protected void sequence_OclType_abstractContents(ISerializationContext context, OclType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Primary_OclExpression returns OclUndefinedExp
	 *     OclUndefinedExp returns OclUndefinedExp
	 *
	 * Constraint:
	 *     {OclUndefinedExp}
	 * </pre>
	 */
	protected void sequence_OclUndefinedExp(ISerializationContext context, OclUndefinedExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     PropertyCall returns OperationCall
	 *     OperationCall returns OperationCall
	 *
	 * Constraint:
	 *     ((operationName=STRING | operationName=ID) (arguments+=OclExpression arguments+=OclExpression*)?)
	 * </pre>
	 */
	protected void sequence_OperationCall(ISerializationContext context, OperationCall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Operation returns Operation
	 *
	 * Constraint:
	 *     (name=ID (parameters+=Parameter parameters+=Parameter+)? returnType=OclType body=OclExpression)
	 * </pre>
	 */
	protected void sequence_Operation(ISerializationContext context, Operation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Primary_OclExpression returns OrderedSetExp
	 *     OrderedSetExp returns OrderedSetExp
	 *
	 * Constraint:
	 *     (elements+=OclExpression elements+=OclExpression*)?
	 * </pre>
	 */
	protected void sequence_OrderedSetExp(ISerializationContext context, OrderedSetExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     OclType returns OrderedSetType
	 *     CollectionType returns OrderedSetType
	 *     OrderedSetType returns OrderedSetType
	 *
	 * Constraint:
	 *     elementType=OclType
	 * </pre>
	 */
	protected void sequence_OrderedSetType(ISerializationContext context, OrderedSetType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ToclPackage.Literals.COLLECTION_TYPE__ELEMENT_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ToclPackage.Literals.COLLECTION_TYPE__ELEMENT_TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOrderedSetTypeAccess().getElementTypeOclTypeParserRuleCall_2_0(), semanticObject.getElementType());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Parameter returns Parameter
	 *     Auxiliary returns Parameter
	 *
	 * Constraint:
	 *     (name=ID type=OclType)
	 * </pre>
	 */
	protected void sequence_Parameter(ISerializationContext context, fr.enseeiht.xtext.tocl.tocl.Parameter semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ToclPackage.Literals.AUXILIARY__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ToclPackage.Literals.AUXILIARY__NAME));
			if (transientValues.isValueTransient(semanticObject, ToclPackage.Literals.AUXILIARY__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ToclPackage.Literals.AUXILIARY__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getParameterAccess().getNameIDTerminalRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getParameterAccess().getTypeOclTypeParserRuleCall_2_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     OclExpression returns PropertyCallExp
	 *     OperatorCallExp returns PropertyCallExp
	 *     OperatorCallExp.OperatorCallExp_1_0 returns PropertyCallExp
	 *     BoolOpCallExp returns PropertyCallExp
	 *     BoolOpCallExp.BoolOpCallExp_1_0_0 returns PropertyCallExp
	 *     EqOpCallExp returns PropertyCallExp
	 *     EqOpCallExp.EqOpCallExp_1_0_0 returns PropertyCallExp
	 *     RelOpCallExp returns PropertyCallExp
	 *     RelOpCallExp.RelOpCallExp_1_0_0 returns PropertyCallExp
	 *     AddOpCallExp returns PropertyCallExp
	 *     AddOpCallExp.AddOpCallExp_1_0_0 returns PropertyCallExp
	 *     IntOpCallExp returns PropertyCallExp
	 *     IntOpCallExp.IntOpCallExp_1_0_0 returns PropertyCallExp
	 *     MulOpCallExp returns PropertyCallExp
	 *     MulOpCallExp.MulOpCallExp_1_0_0 returns PropertyCallExp
	 *     NotOpCallExp returns PropertyCallExp
	 *     PropertyCallExp returns PropertyCallExp
	 *
	 * Constraint:
	 *     (source=Primary_OclExpression calls+=PropertyCall*)
	 * </pre>
	 */
	protected void sequence_PropertyCallExp(ISerializationContext context, PropertyCallExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Primary_OclExpression returns RealExp
	 *     NumericExp returns RealExp
	 *     RealExp returns RealExp
	 *
	 * Constraint:
	 *     realSymbol=DOUBLE
	 * </pre>
	 */
	protected void sequence_RealExp(ISerializationContext context, RealExp semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ToclPackage.Literals.REAL_EXP__REAL_SYMBOL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ToclPackage.Literals.REAL_EXP__REAL_SYMBOL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRealExpAccess().getRealSymbolDOUBLETerminalRuleCall_0(), semanticObject.getRealSymbol());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     OclType returns RealType
	 *     Primitive returns RealType
	 *     NumericType returns RealType
	 *     RealType returns RealType
	 *
	 * Constraint:
	 *     {RealType}
	 * </pre>
	 */
	protected void sequence_RealType(ISerializationContext context, RealType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     OclExpression returns RelOpCallExp
	 *     OperatorCallExp returns RelOpCallExp
	 *     OperatorCallExp.OperatorCallExp_1_0 returns RelOpCallExp
	 *     BoolOpCallExp returns RelOpCallExp
	 *     BoolOpCallExp.BoolOpCallExp_1_0_0 returns RelOpCallExp
	 *     EqOpCallExp returns RelOpCallExp
	 *     EqOpCallExp.EqOpCallExp_1_0_0 returns RelOpCallExp
	 *     RelOpCallExp returns RelOpCallExp
	 *     RelOpCallExp.RelOpCallExp_1_0_0 returns RelOpCallExp
	 *
	 * Constraint:
	 *     (source=RelOpCallExp_RelOpCallExp_1_0_0 operationName=RELOP argument=AddOpCallExp)
	 * </pre>
	 */
	protected void sequence_RelOpCallExp(ISerializationContext context, RelOpCallExp semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ToclPackage.Literals.OPERATOR_CALL_EXP__SOURCE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ToclPackage.Literals.OPERATOR_CALL_EXP__SOURCE));
			if (transientValues.isValueTransient(semanticObject, ToclPackage.Literals.OPERATOR_CALL_EXP__OPERATION_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ToclPackage.Literals.OPERATOR_CALL_EXP__OPERATION_NAME));
			if (transientValues.isValueTransient(semanticObject, ToclPackage.Literals.OPERATOR_CALL_EXP__ARGUMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ToclPackage.Literals.OPERATOR_CALL_EXP__ARGUMENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRelOpCallExpAccess().getRelOpCallExpSourceAction_1_0_0(), semanticObject.getSource());
		feeder.accept(grammarAccess.getRelOpCallExpAccess().getOperationNameRELOPParserRuleCall_1_0_1_0(), semanticObject.getOperationName());
		feeder.accept(grammarAccess.getRelOpCallExpAccess().getArgumentAddOpCallExpParserRuleCall_1_1_0(), semanticObject.getArgument());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Primary_OclExpression returns SelfExp
	 *     SelfExp returns SelfExp
	 *
	 * Constraint:
	 *     {SelfExp}
	 * </pre>
	 */
	protected void sequence_SelfExp(ISerializationContext context, SelfExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Primary_OclExpression returns SequenceExp
	 *     SequenceExp returns SequenceExp
	 *
	 * Constraint:
	 *     (elements+=OclExpression elements+=OclExpression*)?
	 * </pre>
	 */
	protected void sequence_SequenceExp(ISerializationContext context, SequenceExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     OclType returns SequenceType
	 *     CollectionType returns SequenceType
	 *     SequenceType returns SequenceType
	 *
	 * Constraint:
	 *     elementType=OclType
	 * </pre>
	 */
	protected void sequence_SequenceType(ISerializationContext context, SequenceType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ToclPackage.Literals.COLLECTION_TYPE__ELEMENT_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ToclPackage.Literals.COLLECTION_TYPE__ELEMENT_TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSequenceTypeAccess().getElementTypeOclTypeParserRuleCall_2_0(), semanticObject.getElementType());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Primary_OclExpression returns SetExp
	 *     SetExp returns SetExp
	 *
	 * Constraint:
	 *     (elements+=OclExpression elements+=OclExpression*)?
	 * </pre>
	 */
	protected void sequence_SetExp(ISerializationContext context, SetExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     OclType returns SetType
	 *     CollectionType returns SetType
	 *     SetType returns SetType
	 *
	 * Constraint:
	 *     elementType=OclType
	 * </pre>
	 */
	protected void sequence_SetType(ISerializationContext context, SetType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ToclPackage.Literals.COLLECTION_TYPE__ELEMENT_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ToclPackage.Literals.COLLECTION_TYPE__ELEMENT_TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSetTypeAccess().getElementTypeOclTypeParserRuleCall_2_0(), semanticObject.getElementType());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Primary_OclExpression returns StringExp
	 *     StringExp returns StringExp
	 *
	 * Constraint:
	 *     stringSymbol=STRING
	 * </pre>
	 */
	protected void sequence_StringExp(ISerializationContext context, StringExp semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ToclPackage.Literals.STRING_EXP__STRING_SYMBOL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ToclPackage.Literals.STRING_EXP__STRING_SYMBOL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStringExpAccess().getStringSymbolSTRINGTerminalRuleCall_1_0(), semanticObject.getStringSymbol());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     OclType returns StringType
	 *     Primitive returns StringType
	 *     StringType returns StringType
	 *
	 * Constraint:
	 *     {StringType}
	 * </pre>
	 */
	protected void sequence_StringType(ISerializationContext context, StringType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Primary_OclExpression returns SuperExp
	 *     SuperExp returns SuperExp
	 *
	 * Constraint:
	 *     {SuperExp}
	 * </pre>
	 */
	protected void sequence_SuperExp(ISerializationContext context, SuperExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Primary_OclExpression returns TupleExp
	 *     TupleExp returns TupleExp
	 *
	 * Constraint:
	 *     (tuplePart+=TuplePart tuplePart+=TuplePart*)?
	 * </pre>
	 */
	protected void sequence_TupleExp(ISerializationContext context, TupleExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     TuplePart returns TuplePart
	 *
	 * Constraint:
	 *     (varName=STRING type=OclType? initExpression=OclExpression)
	 * </pre>
	 */
	protected void sequence_TuplePart(ISerializationContext context, TuplePart semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     TupleTypeAttribute returns TupleTypeAttribute
	 *
	 * Constraint:
	 *     (name=ID type=OclType)
	 * </pre>
	 */
	protected void sequence_TupleTypeAttribute(ISerializationContext context, TupleTypeAttribute semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ToclPackage.Literals.TUPLE_TYPE_ATTRIBUTE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ToclPackage.Literals.TUPLE_TYPE_ATTRIBUTE__NAME));
			if (transientValues.isValueTransient(semanticObject, ToclPackage.Literals.TUPLE_TYPE_ATTRIBUTE__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ToclPackage.Literals.TUPLE_TYPE_ATTRIBUTE__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTupleTypeAttributeAccess().getNameIDTerminalRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getTupleTypeAttributeAccess().getTypeOclTypeParserRuleCall_2_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     OclType returns TupleType
	 *     TupleType returns TupleType
	 *
	 * Constraint:
	 *     (attributes+=TupleTypeAttribute attributes+=TupleTypeAttribute*)?
	 * </pre>
	 */
	protected void sequence_TupleType(ISerializationContext context, TupleType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Primary_OclExpression returns VariableDeclaration
	 *     VariableExp returns VariableDeclaration
	 *     VariableDeclaration returns VariableDeclaration
	 *
	 * Constraint:
	 *     varName='thisModule'
	 * </pre>
	 */
	protected void sequence_VariableDeclaration(ISerializationContext context, VariableDeclaration semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ToclPackage.Literals.VARIABLE_DECLARATION__VAR_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ToclPackage.Literals.VARIABLE_DECLARATION__VAR_NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVariableDeclarationAccess().getVarNameThisModuleKeyword_0(), semanticObject.getVarName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Primary_OclExpression returns VariableExp
	 *     VariableExp returns VariableExp
	 *
	 * Constraint:
	 *     referredVariable=[Auxiliary|ID]
	 * </pre>
	 */
	protected void sequence_VariableExp(ISerializationContext context, VariableExp semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ToclPackage.Literals.VARIABLE_EXP__REFERRED_VARIABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ToclPackage.Literals.VARIABLE_EXP__REFERRED_VARIABLE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVariableExpAccess().getReferredVariableAuxiliaryIDTerminalRuleCall_0_0_1(), semanticObject.eGet(ToclPackage.Literals.VARIABLE_EXP__REFERRED_VARIABLE, false));
		feeder.finish();
	}
	
	
}
